#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
#ifndef SOCIALRADIO_SWIFT_H
#define SOCIALRADIO_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wnon-modular-include-in-framework-module"
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#pragma clang diagnostic pop
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="SocialRadio",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)
enum ErrorCode : NSInteger;
@class NSError;
@class NSString;
@protocol AutomixIQMusicCacheDelegate;
@protocol AutomixIQStatusObserverDelegate;
@class TunedTrackModel;
@class AutomixIQStatus;
@class AutomixIQWaveformModel;

/// AutomixIQ represents the AutomixIQ SDK and exposes all its functionality. It follows a Singleton pattern.
SWIFT_CLASS("_TtC11SocialRadio9AutomixIQ")
@interface AutomixIQ : NSObject
+ (NSError * _Nonnull)automixIQErrorWithCode:(enum ErrorCode)code SWIFT_WARN_UNUSED_RESULT;
+ (NSString * _Nullable)errorDescriptionWithCode:(enum ErrorCode)code SWIFT_WARN_UNUSED_RESULT;
/// Returns whether or not AutomixIQ is initialised.
/// <ul>
///   <li>
///     returns true if initialised, false otherwise.
///   </li>
/// </ul>
+ (BOOL)initialised SWIFT_WARN_UNUSED_RESULT;
/// Returns whether AutomixIQ can see the internet
///
/// returns:
/// true if internet is available, false otherwise
+ (BOOL)internetAvailable SWIFT_WARN_UNUSED_RESULT;
/// Terminates / deinitialises AutomixIQ. Call this on applicationWillTerminate, or whenever you no longer need it.
- (void)terminate;
/// Returns the singleton instance.
///
/// returns:
/// The singleton instance.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) AutomixIQ * _Nonnull instance;)
+ (AutomixIQ * _Nonnull)instance SWIFT_WARN_UNUSED_RESULT;
/// Forces AutomixIQ to ask its delegate for new credentials
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)forceRefreshCredentialsWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Clears AutomixIQ backing files and recreates them empty
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)clearCacheWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Adds a new music cache delegate
/// \param musicCacheDelegate The delegate to add.
///
- (void)setMusicCacheDelegate:(id <AutomixIQMusicCacheDelegate> _Nonnull)musicCacheDelegate;
/// Adds a new status observer delegate
/// \param statusObserverDelegate The delegate to add.
///
- (void)addStatusObserverDelegate:(id <AutomixIQStatusObserverDelegate> _Nonnull)statusObserverDelegate;
/// Removes a status observer delegate
/// \param statusObserverDelegate The delegate to remove.
///
- (void)removeStatusObserverDelegate:(id <AutomixIQStatusObserverDelegate> _Nonnull)statusObserverDelegate;
/// Turns AutomixIQ on.
/// Returns an error if the engine has not been initialised or has already been turned on.
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)automixOnCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Turns the AutomixIQ player on and starts playback if required as soon as possible at a given track and playback time within the provided playlist.
/// If the playlist is empty this operation will fail and AutomixIQ will be turned off.
/// Returns an error if the engine has not been initialised or has already been turned on.
/// \param identifiers The list of track identifiers that form the playlist you are loading the player with.
///
/// \param metadata An array of TunedTrackModel objects you can pass to the engine so it doesn’t make additional API requests for the corresponding track identifiers metadata. Can be nil.
///
/// \param playTrackIndex The index of the track to begin playback at.
///
/// \param seconds The time within the selected track to begin playback at, in seconds.
///
/// \param autoplay If true, playback will start as soon as possible. Otherwise, playback will start only when calling -(void)play.
///
/// \param contextType A string representing the source of these tracks, for logging purposes (‘playlist’, ‘album’, etc).
///
/// \param contextId The id of the source of these tracks, for logging purposes.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)automixOnIdentifiers:(NSArray<NSString *> * _Nonnull)identifiers metadata:(NSArray<TunedTrackModel *> * _Nullable)metadata playTrackIndex:(int32_t)playTrackIndex seconds:(float)seconds autoplay:(BOOL)autoplay contextType:(NSString * _Nullable)contextType contextId:(NSString * _Nullable)contextId completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Turns the AutomixIQ player off.
/// In order to turn it back on you will have to call -(void)automixOnWithIdentifiers:playTrackIndex:seconds:autoplay:
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// <li>
/// status: The AutomixIQ SDK status when the off command was issued, in case you want to restore it elsewhere.
/// </li>
/// </ul>
///
///
- (void)automixOffWithCompletion:(void (^ _Nullable)(NSError * _Nullable, AutomixIQStatus * _Nonnull))completion;
/// Clears all the tracks in the AutomixIQ playlist
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)resetPlaylistToEmptyWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Loads a new playlist into AutomixIQ
/// Returns an error if the playlist is empty this opperation will fail and AutomixIQ will be turned off.
/// This will stop playback of the currently playing playlist and start the newly loaded one.
/// \param identifiers The list of track identifiers that form the playlist you are loading.
///
/// \param metadata An array of TunedTrackModel objects you can pass to the engine so it doesn’t make additional API requests for the corresponding track identifiers metadata. Can be nil.
///
/// \param playTrackIndex The index of the track to begin playback at.
///
/// \param seconds The time within the selected track to begin playback at, in seconds.
///
/// \param autoplay If true, playback will start as soon as possible. Otherwise, playback will start only when calling -(void)play.
///
/// \param contextType A string representing the source of these tracks, for logging purposes (‘playlist’, ‘album’, etc).
///
/// \param contextId The id of the source of these tracks, for logging purposes.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)loadTracksWithIdentifiers:(NSArray<NSString *> * _Nonnull)identifiers metadata:(NSArray<TunedTrackModel *> * _Nullable)metadata playTrackIndex:(int32_t)playTrackIndex seconds:(float)seconds autoplay:(BOOL)autoplay contextType:(NSString * _Nullable)contextType contextId:(NSString * _Nullable)contextId completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Adds additional tracks to the playlist in AutomixIQ at a given index.
/// Returns an erorr if the index is out of bounds.
/// \param identifiers The list of track identifiers to add.
///
/// \param metadata An array of TunedTrackModel objects you can pass to the engine so it doesn’t make additional API requests for the corresponding track identifiers metadata. Can be nil.
///
/// \param contextType A string representing the source of these tracks, for logging purposes (‘playlist’, ‘album’, etc).
///
/// \param contextId The id of the source of these tracks, for logging purposes.
///
/// \param index The index at which this track will be added. If index == 0, it will be the first track of the playlist. If index == playlist.size() the track will be added last. If inbetween, it’ll push tracks from the index onwards back in the playlist to make room.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)addTracksWithIdentifiers:(NSArray<NSString *> * _Nonnull)identifiers metadata:(NSArray<TunedTrackModel *> * _Nullable)metadata contextType:(NSString * _Nullable)contextType contextId:(NSString * _Nullable)contextId index:(int32_t)index completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Adds a single track to the AutomixIQ playlist at a given index.
/// Returns an erorr if the index is out of bounds.
/// \param identifier The track identifier to be added.
///
/// \param metadata TunedTrackModel object you can pass to the engine so it doesn’t make additional API requests for the corresponding track identifier metadata. Can be nil.
///
/// \param contextType A string representing the source of these tracks, for logging purposes (‘playlist’, ‘album’, etc).
///
/// \param contextId The id of the source of these tracks, for logging purposes.
///
/// \param index The index at which this track will be added. If index == 0, it will be the first track of the playlist. If index == playlist.size() the track will be added last. If inbetween, it’ll push tracks from the index onwards back in the playlist to make room.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)addTrackWithIdentifier:(NSString * _Nonnull)identifier metadata:(TunedTrackModel * _Nullable)metadata contextType:(NSString * _Nullable)contextType contextId:(NSString * _Nullable)contextId index:(int32_t)index completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Removes a track at a given index in the AutomixIQ playlist.
/// Returns an erorr if the index is out of bounds.
/// \param index The index to remove.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)removeTrackAt:(int32_t)index completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Moves the track from one index to a different index.
/// \param index Index of the track to move
///
/// \param toIndex Index where it will land
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)moveTrackAt:(int32_t)index toIndex:(int32_t)toIndex completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Starts playback if paused.
/// Returns an error if the player is already playing.
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)playWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Pauses playback if playing.
/// Returns an error if the player is already paused.
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)pauseWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Moves the player to the beginning of the next track
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)nextWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Moves the player to the beginning of the previous track
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)previousWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Moves the player to the beginning of the current track
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)backWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// If on, after a playlist is done it restarts. Otherwise, it pauses.
/// This defaults to false on initialisation and should be set to match the state of the consumer’s UI
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)toggleReplayWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion SWIFT_DEPRECATED_MSG("Toggles are evil, please use setReplay(on:completion:)");
/// Tells AutomixIQ whether or not it should restart the playlist when reaching the end.
/// If on then playback will restart at the beginning otherwise it pauses at the end.
/// \param on true if you want replay, false otherwise.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)setReplayOn:(BOOL)on completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Jumps playback on the current track to the desired timestamp as soon as possible.
/// This will mix the track with itself so the seek is beat-matched and as seamless as possible, which means the landing position will be close but not exactly the fed timestamp.
/// \param seconds The timestamp to seek to.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)seekToSeconds:(float)seconds completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Jumps playback to the beginning of the track at the desired index as soon as possible.
/// \param index the index of the track to jump to
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
- (void)skipToTrackAtIndex:(NSInteger)index completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Sets the filter explicit lyrics flag.
/// When set to on, AutomixIQ will skip over the tracks that have the explicit content flag set in their metadata by mixing the currently playing track with the first available non-explicit track in the queue.
/// \param filterExplicit value to set, true if you wish for explicit tracks to not play, false otherwise.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)setFilterExplicitWithFilterExplicit:(BOOL)filterExplicit completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Sets a new order to the playlist while continuing to play the current track
/// \param newOrder The new ordered playlist whose items need to match the existing playlist.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)reorderTracksWithNewOrder:(NSArray<NSString *> * _Nonnull)newOrder completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Makes AutomixIQ play a given track until the end and then pause.
/// This is useful if you need to play any other content between tracks such as advertisements.
/// Returns an error if you call this on the last track
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)playTrackUntilEndThenPauseWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Sets AutomixIQ’s play speed to a given value between 0.5 and 2, where 0.5 is half speed and 2 is double speed.
/// \param playSpeed The play speed to set
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)setAutomixPlaySpeed:(float)playSpeed completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Sets AutomixIQ’s volume to a given value between 0 and 1. If muted, calling this will cause AutomixIQ to unmute.
/// \param volumeNormalised The volume value to set
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)setAutomixVolumeNormalised:(float)volumeNormalised completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Toggles the AutomixIQ SDK mute
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)toggleMuteWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion SWIFT_DEPRECATED_MSG("Toggles are evil, please use setMute(on:completion:)");
/// Mutes AutomixIQ
/// \param on true to mute AutomixIQ, false otherwise.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)setMuteOn:(BOOL)on completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Sets AutomixIQ’s preferred transition duration - transitions will not be exactly this duration but AutomixIQ will favour transitions with duration close to this one.
/// Setting it to 0 disables this hint and allows the engine to select the transition duration based on trained genre-based transition data.
/// \param duration The desired transition duration in seconds
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)setPreferredTransitionDurationSeconds:(float)duration completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Makes AutomixIQ repeat the currently playing track.
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)loopPlayingTrackWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Makes AutomixIQ stop repeating the currently playing track.
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)stopLoopingPlayingTrackWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Enables / Disables vinyl pause sound effect.
/// \param enabled true if enabled, false otherwise
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)setVinylStartStopEnabled:(BOOL)enabled completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Returns the on/off status of AutomixIQ.
/// <ul>
///   <li>
///     returns true if on, false otherwise.
///   </li>
/// </ul>
- (BOOL)on SWIFT_WARN_UNUSED_RESULT;
/// Sets the resolution of the waveform data for a track
/// \param waveformPointsPerTrack The number of points representing a waveform for a track, maximum of 1024, defaults to 256
///
- (void)setWaveformPointsPerTrack:(int32_t)waveformPointsPerTrack;
/// Gets the waveform data for a track.
/// <ul>
///   <li>
///     returns the waveform data
///   </li>
/// </ul>
/// \param identifier The identifier of a track
///
/// \param applyTransitions true if you want the transition to be applied to the waveform data, false if you want the original waveform data
///
- (AutomixIQWaveformModel * _Nullable)waveformDataForTrackWithIdentifier:(NSString * _Nonnull)identifier applyTransitions:(BOOL)applyTransitions SWIFT_WARN_UNUSED_RESULT;
/// Gets the waveform data for a track.
/// <ul>
///   <li>
///     returns the waveform data
///   </li>
/// </ul>
/// \param identifier The identifier of a track
///
/// \param applyEnterTransition true if you want the transition to the start of the track to be applied to the waveform data, false otherwise
///
/// \param applyExitTransition true if you want the transition to the end of the track to be applied to the waveform data, false otherwise
///
- (AutomixIQWaveformModel * _Nullable)waveformDataForTrackWithIdentifier:(NSString * _Nonnull)identifier applyEnterTransition:(BOOL)applyEnterTransition applyExitTransition:(BOOL)applyExitTransition SWIFT_WARN_UNUSED_RESULT;
/// Gets the placeholder waveform data for a track.
/// <ul>
///   <li>
///     returns the waveform data
///   </li>
/// </ul>
/// \param identifier The identifier of a track
///
- (AutomixIQWaveformModel * _Nullable)placeholderWaveformDataForTrackWithIdentifier:(NSString * _Nonnull)identifier SWIFT_WARN_UNUSED_RESULT;
/// Gets the current automix status
/// <ul>
///   <li>
///     returns the current automix status
///   </li>
/// </ul>
- (AutomixIQStatus * _Nullable)automixStatus SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC11SocialRadio15AutomixIQConfig")
@interface AutomixIQConfig : NSObject
- (nonnull instancetype)initWithApiKey:(NSString * _Nonnull)apiKey country:(NSString * _Nonnull)country storeId:(NSString * _Nonnull)storeId applicationId:(NSString * _Nonnull)applicationId OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nonnull apiKey;
@property (nonatomic, copy) NSString * _Nonnull country;
@property (nonatomic, copy) NSString * _Nonnull storeId;
@property (nonatomic, copy) NSString * _Nonnull applicationId;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSData;

/// AutomixIQMusicCacheDelegate protocol defines the methods to be implemented with storing and providing cached track data
SWIFT_PROTOCOL("_TtP11SocialRadio27AutomixIQMusicCacheDelegate_")
@protocol AutomixIQMusicCacheDelegate <NSObject>
/// Called by AutomixIQ when a track has been fully downloaded. This can be used to cache the track locally on the user’s device.
/// \param trackId The trackId of the asset in Tuned Global’s backend.
///
/// \param data The unencrypted track data.
///
- (void)trackDownloadCompletedWithTrackId:(NSString * _Nonnull)trackId data:(NSData * _Nonnull)data;
/// Called by AutomixIQ when a track download progress has changed.
/// \param trackId The id of the track that AutomixIQ is streaming.
///
/// \param progress The track download progress, between 0 (none) and 1 (complete).
///
- (void)trackDownloadProgressChangedWithTrackId:(NSString * _Nonnull)trackId progress:(float)progress;
/// Called by AutomixIQ before attempting to download a track to allow the client to provide any cached track data, return nil if not available.
/// \param trackId The id of the track that AutomixIQ is streaming.
///
///
/// returns:
/// the entire unencrypted track data, nil if not available.
- (NSData * _Nullable)getCachedTrackWithTrackId:(NSString * _Nonnull)trackId SWIFT_WARN_UNUSED_RESULT;
/// Called by AutomixIQ before attempting to download a tracks metadata to allow the client to provide any cached metadata, return nil if not available.
/// \param trackId The id of the track that AutomixIQ  is streaming.
///
///
/// returns:
/// the metadata of the track, nil if not available.
- (TunedTrackModel * _Nullable)getTrackMetadataWithTrackId:(NSString * _Nullable)trackId SWIFT_WARN_UNUSED_RESULT;
@end

/// AutomixIQPlaybackEventType is an enum of all the available playback events
/// \param trackPlayStart Start of track playback
///
/// \param trackPlayPlayed5Secs Track has played for 5 seconds
///
/// \param trackPlayHeartbeat30Secs Track has played for 30 seconds, this is called every 30 seconds of playback
///
/// \param trackPlayStartMixingIntoNext Track has started transitioning into the next track
///
/// \param trackPlaySkipped Track has been skipped to the next track (this is also called when seeking through the same track)
///
/// \param trackPlayFinished Track has finished playback (if transitioning this is called at the end of the transition for the first track)
///
/// \param mixPlaybackEnded Queue has reached the end and there are no more tracks to play
///
typedef SWIFT_ENUM(NSInteger, AutomixIQPlaybackEventType, open) {
  AutomixIQPlaybackEventTypeTrackPlayStart = 0,
  AutomixIQPlaybackEventTypeTrackPlayPlayed5Secs = 1,
  AutomixIQPlaybackEventTypeTrackPlayHeartbeat30Secs = 2,
  AutomixIQPlaybackEventTypeTrackPlayStartMixingIntoNext = 3,
  AutomixIQPlaybackEventTypeTrackPlaySkipped = 4,
  AutomixIQPlaybackEventTypeTrackPlayFinished = 5,
  AutomixIQPlaybackEventTypeMixPlaybackEnded = 6,
};

enum AutomixIQPlaylistOperationType : NSInteger;

/// AutomixIQPlaylistOperation models a move, add or remove operation of a track in a playlist.
SWIFT_CLASS("_TtC11SocialRadio26AutomixIQPlaylistOperation")
@interface AutomixIQPlaylistOperation : NSObject
/// The type of operation, Add / Remove / Move
@property (nonatomic) enum AutomixIQPlaylistOperationType type;
/// The index int the playlist the track was removed from or was moved from, -1 otherwise.
@property (nonatomic) NSInteger fromIndex;
/// The index int the playlist the track was added to or was moved to, -1 otherwise.
@property (nonatomic) NSInteger toIndex;
/// The identifier of the track.
@property (nonatomic, copy) NSString * _Nullable trackIdentifier;
/// The unique identifier for this track in this playlist, i.e. if the same track happens to appear twice in a playlist this identifier will differ.
@property (nonatomic) NSInteger trackInstance;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM(NSInteger, AutomixIQPlaylistOperationType, open) {
  AutomixIQPlaylistOperationTypeAdded = 0,
  AutomixIQPlaylistOperationTypeRemoved = 1,
  AutomixIQPlaylistOperationTypeMoved = 2,
};

enum AutomixIQStatusVariable : NSInteger;
@class NSNumber;

/// AutomixIQStatus models the State of the AutomixIQ during playback.
SWIFT_CLASS("_TtC11SocialRadio15AutomixIQStatus")
@interface AutomixIQStatus : NSObject <NSCopying>
/// Represents if sound is playing from Automix SDK, true if it is, false otherwise.
@property (nonatomic) BOOL playing;
/// Represents if more than one track is concurrently playing from Automix SDK (mixing), true if it is, false otherwise.
@property (nonatomic) BOOL mixing;
/// Represents the identifier of the currently playing track if not mixing, the front track of the two mixed together if mixing. This would be the track a UI needs to show as playing or active.
@property (nonatomic, copy) NSString * _Nullable playingTrackIdentifier;
/// Represents the position of the currently playing track in the playlist if not mixing, the front track of the two mixed together if mixing. This would be the track a UI needs to show as playing or active.
/// If seeking, it reports seek landing track index until jump is complete. This should be use on the UI.
@property (nonatomic) NSInteger playingTrackIndex;
/// Represents the current playback time of the playing track. If seeking, it reports seek landing time until jump is complete. This should be use on the UI.
@property (nonatomic) NSTimeInterval playingTrackCurrentTime;
/// Represents the total playback time of the playing track.
@property (nonatomic) NSTimeInterval playingTrackTotalTime;
/// Represents the percentage of downloaded track.
@property (nonatomic) float playingTrackStreamingProgress;
/// Represents wether the engine will replay the current playlist when it ends.
@property (nonatomic) BOOL replayOn;
/// Represents wether the engine is ready to skip to a previous track.
@property (nonatomic) BOOL canSkipToPrevious;
/// Represents wether the engine is ready to skip to the beginning of the current track.
@property (nonatomic) BOOL canBack;
/// Represents wether the engine is ready to skip to the next track. If playing the last track of the playlist and “repeat” is off, this will be false.
@property (nonatomic) BOOL canSkipToNext;
/// Represents wether the engine is ready to receive a play or pause command.
@property (nonatomic) BOOL canPlayPause;
/// Represents wether the engine is ready to receive a seek command.
@property (nonatomic) BOOL canSeek;
/// Represents wether the engine is ready to receive a reorder tracks command.
@property (nonatomic) BOOL canReorderTracks;
/// Represents wether the mix is readsy to play or currently loading.
@property (nonatomic) BOOL readyToPlay;
/// Represents wether the ‘next’ action would lead to a proper mix or a regular jumps. Depends on wether we had enough time to analyze the next track or not.
@property (nonatomic) BOOL canMixNow;
/// Represents the list of track identifiers in the order they will be played
@property (nonatomic, copy) NSArray<NSString *> * _Nonnull playlist;
/// Represents whether Automix SDK is muted or not. True if muted, false otherwise.
@property (nonatomic) BOOL muted;
/// Represents the Automix SDK play speed as a factor, from 0.5 to 2
@property (nonatomic) float playSpeed;
/// Represents the Automix SDK volume from 1 to 0. Note the device’s iOS Volume acts as a master over this one: if iOS’volume is 0, no sound will be put out regardless of this value.
@property (nonatomic) float normalisedVolume;
/// Represents the preferred Automix SDK transition duration, 0 if disabled.
@property (nonatomic) float preferredTransitionDurationSeconds;
/// Represents the track Automix SDK is currently looping, nil if none is looping
@property (nonatomic, copy) NSString * _Nullable requestedLoopTrackIdentifier;
/// Represents the track Automix SDK is currently flagged to be paused at the end, nil if none is
@property (nonatomic, copy) NSString * _Nullable requestedPauseTrackIdentifier;
/// Represents wether the engine does the vinyl sound effects when play/pause
@property (nonatomic) BOOL vinylStartStop;
/// Represents the duration of the upcoming transition, 0 if no transition available
@property (nonatomic) float nextTransitionDuration;
/// Represents the track time in seconds in which the next (or current) transition starts
@property (nonatomic) float transitionStartTimeSeconds;
/// Represents the tracks that failed loading for any reason
@property (nonatomic, copy) NSArray<NSString *> * _Nullable failedTrackLoadIdentifiers;
/// Represents if the SDK can be turned On or off. It is true if not other On / Off action is ongoing, flase otherwise. When this switch is true, On /Off actions return an error.
@property (nonatomic) BOOL canOnOff;
@property (nonatomic, copy) NSString * _Nullable playingTrackOriginalSessionId;
@property (nonatomic) BOOL explicitLyricsFiltering;
@property (nonatomic) int64_t mixId;
@property (nonatomic) NSInteger playbackMode;
@property (nonatomic, copy) NSDictionary<NSString *, NSArray<AutomixIQPlaylistOperation *> *> * _Nullable playlistDiff;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
+ (NSString * _Nonnull)automixIQStatusVariableName:(enum AutomixIQStatusVariable)variable SWIFT_WARN_UNUSED_RESULT;
- (id _Nonnull)variableValue:(enum AutomixIQStatusVariable)variable SWIFT_WARN_UNUSED_RESULT;
+ (NSArray<NSNumber *> * _Nonnull)allStatusVariables SWIFT_WARN_UNUSED_RESULT;
@end


/// AutomixIQStatusObserverDelegate protocol defines the methods to be implemented with observing the status of AutomixIQ to reflect it on a UI.
SWIFT_PROTOCOL("_TtP11SocialRadio31AutomixIQStatusObserverDelegate_")
@protocol AutomixIQStatusObserverDelegate <NSObject>
/// Called when the status of AutomixIQ changes
/// \param variables a list of AutomixIQStatusVariable that changed since last time this method was called, or since AutomixIQ was initialised.
///
/// \param status the current status of AutomixIQ
///
- (void)statusChangedWithVariables:(NSArray<NSNumber *> * _Nonnull)variables status:(AutomixIQStatus * _Nonnull)status;
@optional
/// Called when a playback event of AutomixIQ happens
/// \param type the playback event type
///
/// \param identifier the track identifier this event refers to
///
/// \param originalSessionId the initial session id for the track this event refers to. AutomixIQ may use more session ids as needed if the session expires and it needs more data.
///
/// \param status the current status of AutomixIQ
///
- (void)playbackEventWithType:(enum AutomixIQPlaybackEventType)type identifier:(NSString * _Nullable)identifier originalSessionId:(NSString * _Nullable)originalSessionId status:(AutomixIQStatus * _Nullable)status;
/// Called when waveform data for a track is available
/// \param identifier the identifier of the track
///
- (void)waveformDataAvailableWithIdentifier:(NSString * _Nonnull)identifier;
@end

/// AutomixIQ status variable type
typedef SWIFT_ENUM(NSInteger, AutomixIQStatusVariable, open) {
  AutomixIQStatusVariablePlaying = 0,
  AutomixIQStatusVariableMixing = 1,
  AutomixIQStatusVariablePlayingTrackIdentifier = 2,
  AutomixIQStatusVariablePlayingTrackIndex = 3,
  AutomixIQStatusVariablePlayingTrackCurrentTime = 4,
  AutomixIQStatusVariablePlayingTrackTotalTime = 5,
  AutomixIQStatusVariablePlayingTrackStreamingProgress = 6,
  AutomixIQStatusVariableReplayOn = 7,
  AutomixIQStatusVariableCanSkipToPrevious = 8,
  AutomixIQStatusVariableCanBack = 9,
  AutomixIQStatusVariableCanSkipToNext = 10,
  AutomixIQStatusVariableCanPlayPause = 11,
  AutomixIQStatusVariableCanSeek = 12,
  AutomixIQStatusVariableCanReorderTracks = 13,
  AutomixIQStatusVariableReadyToPlay = 14,
  AutomixIQStatusVariableCanMixNow = 15,
  AutomixIQStatusVariablePlaylist = 16,
  AutomixIQStatusVariableMuted = 17,
  AutomixIQStatusVariablePlaySpeed = 18,
  AutomixIQStatusVariableNormalisedVolume = 19,
  AutomixIQStatusVariablePreferredTransitionDurationSeconds = 20,
  AutomixIQStatusVariableRequestedLoopTrackIdentifier = 21,
  AutomixIQStatusVariableRequestedPauseTrackIdentifier = 22,
  AutomixIQStatusVariableVinylStartStop = 23,
  AutomixIQStatusVariableNextTransitionDuration = 24,
  AutomixIQStatusVariableTransitionStartTimeSeconds = 25,
  AutomixIQStatusVariableFailedTrackLoadIdentifiers = 26,
  AutomixIQStatusVariableCanOnOff = 27,
  AutomixIQStatusVariablePlayingTrackOriginalSessionId = 28,
  AutomixIQStatusVariableExplicitLyricsFiltering = 29,
  AutomixIQStatusVariableMixId = 30,
  AutomixIQStatusVariablePlaybackMode = 31,
  AutomixIQStatusVariablePlaylistDiff = 32,
};

enum TunedLogLevel : NSInteger;

/// AutomixIQStreamingDelegate protocol defines the methods to be implemented with providing AutomixIQ the information it requires to play content.
SWIFT_PROTOCOL("_TtP11SocialRadio26AutomixIQStreamingDelegate_")
@protocol AutomixIQStreamingDelegate <NSObject>
@optional
/// Called by AutomixIQ when it wishes to output a log message
/// \param logLevel The log level
///
/// \param message The message it wishes to log.
///
- (void)logAutomixIQMessageWithLogLevel:(enum TunedLogLevel)logLevel message:(NSString * _Nonnull)message;
@required
/// Called by AutomixIQ to learn if it is allowed to stream content that is protected by some form of authentication.
/// An example is, an implementation via an API behind OAuth would return true if access and refresh tokens are available, false otherwise
///
/// returns:
/// true if it is allowed or there are no authentication requirements, false otherwise
- (BOOL)isLoggedIn SWIFT_WARN_UNUSED_RESULT;
/// Called by AutomixIQ regularly while something is being played, this can be used if you have restrictions on the number of devices that can play simultaneously
/// \param completion Code to be executed upon completing the asynchronous request
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// <li>
/// canContinuePlaying: true if the device can continue playing, false otherwise..
/// </li>
/// </ul>
///
///
- (void)asyncCheckDeviceStatusWithCompletion:(void (^ _Nonnull)(NSError * _Nullable, BOOL))completion;
/// Called by Automix to learn the identity of the device requesting to stream audio, for those services that require it.
/// An example would be, a service that only allows one device to stream at any one time, would need to know the identity of the device to provide the stream.
///
/// returns:
/// the unique identifier of the device that will be streaming content, nil if unknown or unnecessary
- (NSString * _Nullable)getDeviceIdentifier SWIFT_WARN_UNUSED_RESULT;
/// Called by AutomixIQ to obtain the URL to stream audio from, a sessionId if the URL is to be salted with one, and the URL to report playback events if required.
/// \param streamingDeviceId The id of the device attempting to stream content within the streaming APIs.
///
/// \param sessionId The current session Id if available. If one is provided and no longer valid a renewed one will be returned.
///
/// \param trackId The id of the track that AutomixIQ is attempting to stream.
///
/// \param completion Code to be executed upon completing the asynchronous request
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// <li>
/// url: the URL that points to the asset to be played, nil in case of an error.
/// </li>
/// <li>
/// newSessionId: the session Id of the stream, nil if not required or not available.
/// </li>
/// <li>
/// reportingURLS: the set of reporting URLs if available, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)asyncGetStreamWithStreamingDeviceId:(NSString * _Nonnull)streamingDeviceId sessionId:(NSString * _Nonnull)sessionId trackId:(NSString * _Nonnull)trackId completion:(void (^ _Nonnull)(NSError * _Nullable, NSString * _Nullable, NSString * _Nullable))completion;
/// Called by AutomixIQ when it requires the metadata of a track in order to load it.
/// \param trackId The id of the track that AutomixIQ is attempting to stream.
///
/// \param completion Code to be executed upon completing the asynchronous request
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// <li>
/// track: the metadata of the track, nil if an error ocurred.
/// </li>
/// </ul>
///
///
- (void)asyncGetTrackMetadataWithTrackId:(NSString * _Nonnull)trackId completion:(void (^ _Nonnull)(NSError * _Nullable, TunedTrackModel * _Nullable))completion;
/// Called by AutomixIQ when playback of a track has fulfilled the requirements to report a playback event.
/// \param trackId The id of the track that AutomixIQ is streaming.
///
/// \param seconds The number of seconds the track has been playing up until this time.
///
/// \param guid the identifier of this play
///
/// \param logPlayType A descriptor of the event, one of the following: “Start”, “End”, “Progress”, “Skip”, “Unknown”.
///
/// \param source A descriptor of the type of source of the track being reported, like “Album”, “Playlist”, etc.
///
/// \param sourceId An identifier of the source of the track being reported.
///
/// \param completion Code to be executed upon completing the asynchronous request
///
/// \a completion parameters:
/// <ul>
/// <li>
/// success: true if the report was filed successfully, false otherwise.
/// </li>
/// </ul>
///
///
- (void)asyncLogPlayEventWithTrackId:(NSString * _Nonnull)trackId seconds:(NSInteger)seconds guid:(NSString * _Nonnull)guid logPlayType:(NSString * _Nonnull)logPlayType source:(NSString * _Nullable)source sourceId:(NSString * _Nullable)sourceId completion:(void (^ _Nonnull)(BOOL))completion;
/// Called by AutomixIQ when a track has been fully downloaded. This can be used to cache the track locally on the user’s device.
/// \param trackId The id of the track that the AutomixIQ SDK is streaming.
///
/// \param data The track data as an array of bytes.
///
- (void)trackDownloadCompletedWithTrackId:(NSString * _Nonnull)trackId data:(NSData * _Nonnull)data;
/// Called by AutomixIQ when a track download progress has changed.
/// \param trackId The id of the track that AutomixIQ is streaming.
///
/// \param progress The track download progress, between 0 (none) and 1 (complete).
///
- (void)trackDownloadProgressChangedWithTrackId:(NSString * _Nonnull)trackId progress:(float)progress;
/// Called by AutomixIQ before attempting to download a track to allow the client to provide any cached track data, return nil if not available.
/// \param trackId The id of the track that AutomixIQ is streaming.
///
///
/// returns:
/// the entire unencrypted track data, nil if not available.
- (NSData * _Nullable)syncGetCachedTrackWithTrackId:(NSString * _Nonnull)trackId SWIFT_WARN_UNUSED_RESULT;
/// Called by AutomixIQ before attempting to download a tracks metadata to allow the client to provide any cached metadata, return nil if not available.
/// \param trackId The id of the track that AutomixIQ  is streaming.
///
///
/// returns:
/// the metadata of the track, nil if not available.
- (TunedTrackModel * _Nullable)syncGetTrackMetadataWithTrackId:(NSString * _Nullable)trackId SWIFT_WARN_UNUSED_RESULT;
/// AutomixIQ calls this function to provide a chance to cache metadata to shortcut future requests.
- (void)cacheMetadata:(NSArray<TunedTrackModel *> * _Nonnull)metadata;
@end


/// AutomixIQWaveformModel models the waveform of a track.
SWIFT_CLASS("_TtC11SocialRadio22AutomixIQWaveformModel")
@interface AutomixIQWaveformModel : NSObject
/// The normalised X axis, from 0 (meaning start of the track) to 1 (meaning end of the track)
@property (nonatomic, copy) NSArray<NSNumber *> * _Nullable xAxis;
/// The energy of the track
@property (nonatomic, copy) NSArray<NSNumber *> * _Nullable yAxis;
/// The index the left transition starts
@property (nonatomic) NSInteger leftTransitionStartIndex;
/// The index the left transition ends
@property (nonatomic) NSInteger leftTransitionEndIndex;
/// The index the right transition starts
@property (nonatomic) NSInteger rightTransitionStartIndex;
/// The index the right transition ends
@property (nonatomic) NSInteger rightTransitionEndIndex;
/// The number of indices representing a second (x-axis scale)
@property (nonatomic) float indicesPerSecond;
/// The time in the track the left transition starts at, in seconds
@property (nonatomic) float leftTransitionStartTime;
/// The time in the track the left transition ends at, in seconds
@property (nonatomic) float leftTransitionEndTime;
/// The duration of the left transition in track time, in seconds
@property (nonatomic) float leftTransitionDuration;
/// The time in the track the right transition starts at, in seconds
@property (nonatomic) float rightTransitionStartTime;
/// The time in the track the right transition ends at, in seconds
@property (nonatomic) float rightTransitionEndTime;
/// The duration of the right transition, in seconds
@property (nonatomic) float rightTransitionDuration;
/// The duration of the track, in seconds
@property (nonatomic) float trackDurationSeconds;
/// true if this waveform is placeholder data, false otherwise
@property (nonatomic) BOOL placeholder;
/// The time in the current track where the next track’s starting duration would be. This is not where the next track would begin playback as the first few seconds may be muted to create a better transition.
/// This is helpful to align waveforms when rendering transitions.
@property (nonatomic) float nextTrack0SecondsAnchorTime;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// \param notMainThread Thrown when you attempt to use the SDK from any thread not main
///
/// \param sdkNotInitialised Thrown when you attempt to use the SDK prior to initialising it
///
/// \param sdkNotOn Thrown when you attempt to use playback controls when AutomixIQ is not on
///
/// \param sdkAlreadyOn Thrown when you attempt to turn on AutomixIQ but it is already on
///
/// \param loadTracksEmptyPlaylist Thrown when you attempt to load an empty playlist
///
/// \param loadTracksOutOfBounds 
///
/// \param addTrackPlaylistDoesNotExist 
///
/// \param addTrackOutOfBounds Thrown when you attempt to insert a track at a position outside the bounds of the loaded playlist
///
/// \param addTrackNoMetadata Thrown when the metadata for a track you are trying to load is not available and could not be downloaded
///
/// \param addTrackInternalError Thrown when AutomixIQ fails internally (not user error)
///
/// \param removeTrackOutOfBounds Thrown when you attempt to remove a track at a position outside the bounds of the loaded playlist
///
/// \param playAlreadyPlaying Thrown when you attempt to play but AutomixIQ is already playing
///
/// \param pauseAlreadyPaused Thrown when you attempt to pause but AutomixIQ is already paused
///
/// \param previousNoTrackAvailable Thrown when you attempt to go to the previous track but AutomixIQ is already on the first in the playlist and “Repeat” is off
///
/// \param nextNoTrackAvailable Thrown when you attempt to go to the next track but AutomixIQ is already on the last in the playlist and “Repeat” is off
///
/// \param backNoTrackAvailable Thrown when you attempt to go to the start of a track but the playlist is empty
///
/// \param seekNoTrackAvailable Thrown when you attempt to seek to a track but the playlist is empty or the index is out of bounds of the playlist
///
/// \param seekNoCurrentTrack Thrown when you attempt to seek within a track but the playlist is empty or the track is not yet loaded
///
/// \param reorderMissingTrack Thrown when you attempt to move a track that is not on the loaded playlist
///
/// \param playToEndMissingTrack Thrown when you attempt to select a track to be played until the end but that track is not on the loaded playlist
///
/// \param moveTrackOutOfBounds Thrown when you attempt to move a track at a position outside the bounds of the loaded playlist
///
/// \param startLoopingNoLoopingTrack Thrown when you attempt to stop looping a track but that track is not on the loaded playlist
///
/// \param stopLoopingNoLoopingTrack Thrown when you attempt to loop a track but that track is not on the loaded playlist
///
/// \param unimplemented Thrown when you attempt to use an unimplemented method of the SDK
///
/// \param cancelled Thrown when an action you previously issued to AutomixIQ is cancelled due to another user initialed action that overrides it
///
/// \param onAlreadyTurningOn Thrown when you attempt to turn AutomixIQ on while it is already turning on
///
/// \param onWhileTurningOff Thrown when you attempt to turn AutomixIQ on while it is already turning off
///
/// \param offAlreadyTurningOff Thrown when you attempt to turn AutomixIQ off while it is already turning off
///
/// \param offWhileTurningOn Thrown when you attempt to turn AutomixIQ off while it is already turning on
///
/// \param cannotCreateChannelLayout Thrown when AutomixIQ fails to set up the channel layout
///
/// \param cannotCreateInputBuffer Thrown when AutomixIQ fails to set up the input buffer
///
/// \param cannotSetupAVAudioSession Thrown when AutomixIQ fails to set up the AVAudioSession
///
/// \param cannotStartAudioEngine Thrown when AutomixIQ fails to start the audio engine
///
/// \param cannotRestoreAudioSession Thrown when AutomixIQ fails to restore the audio session to the state it found it when you turned it on
///
/// \param failedToStop Thrown when AutomixIQ is unable to be stopped
///
/// \param cannotLoadExplicitLyricsTrack Thrown when you attempt to load an explicit track but the setting to filter out explicit tracks is on
///
typedef SWIFT_ENUM(NSInteger, ErrorCode, open) {
  ErrorCodeSdkAlreadyInitialised = 1001,
  ErrorCodeSdkInitialisationUnauthorised = 1002,
  ErrorCodeNoInternetAvailable = 1003,
  ErrorCodeNoInternetAvailableTooLongOffline = 1004,
  ErrorCodeOfflineNoTunedUserIdAvailable = 1005,
  ErrorCodeNotMainThread = 1006,
  ErrorCodeSdkNotInitialised = 1007,
  ErrorCodeSdkNotInitialisedVersionNoLongerSupported = 1008,
  ErrorCodeSdkNotOn = 1009,
  ErrorCodeSdkAlreadyOn = 1010,
  ErrorCodeLoadTracksEmptyPlaylist = 1011,
  ErrorCodeLoadTracksOutOfBounds = 1012,
  ErrorCodeAddTrackPlaylistDoesNotExist = 1013,
  ErrorCodeAddTrackOutOfBounds = 1014,
  ErrorCodeAddTrackNoMetadata = 1015,
  ErrorCodeAddTrackInternalError = 1016,
  ErrorCodeRemoveTrackOutOfBounds = 1017,
  ErrorCodePlayAlreadyPlaying = 1018,
  ErrorCodePauseAlreadyPaused = 1019,
  ErrorCodeNextNoTrackAvailable = 1020,
  ErrorCodePreviousNoTrackAvailable = 1021,
  ErrorCodeBackNoTrackAvailable = 1022,
  ErrorCodeSeekNoTrackAvailable = 1023,
  ErrorCodeSeekNoCurrentTrack = 1024,
  ErrorCodeReorderMissingTrack = 1025,
  ErrorCodePlayToEndMissingTrack = 1026,
  ErrorCodePlayToEndMixEnd = 1027,
  ErrorCodeMoveTrackOutOfBounds = 1028,
  ErrorCodeStartLoopingNoLoopingTrack = 1029,
  ErrorCodeStopLoopingNoLoopingTrack = 1030,
  ErrorCodeUnable_to_load_mix = 1031,
  ErrorCodeUnimplemented = 1032,
  ErrorCodeCancelled = 1033,
  ErrorCodeOnAlreadyTurningOn = 1034,
  ErrorCodeOnWhileTurningOff = 1035,
  ErrorCodeOffAlreadyTurningOff = 1036,
  ErrorCodeOffWhileTurningOn = 1037,
  ErrorCodeCannotCreateChannelLayout = 1038,
  ErrorCodeCannotCreateInputBuffer = 1039,
  ErrorCodeCannotSetupAVAudioSession = 1040,
  ErrorCodeCannotStartAudioEngine = 1041,
  ErrorCodeCannotRestoreAudioSession = 1042,
  ErrorCodeFailedToStop = 1043,
  ErrorCodeCannotLoadExplicitLyricsTrack = 1044,
};

@class SocialRadioUser;
@class SocialRadioSocialCredentials;
@class NSURLQueryItem;
@class NSHTTPURLResponse;

SWIFT_PROTOCOL("_TtP11SocialRadio21SocialBackendDelegate_")
@protocol SocialBackendDelegate
- (SocialRadioUser * _Nullable)loggedInUser SWIFT_WARN_UNUSED_RESULT;
- (void)refreshSocialCredentialsWithOldAccessToken:(NSString * _Nullable)oldAccessToken refreshToken:(NSString * _Nullable)refreshToken tokenType:(NSString * _Nullable)tokenType completion:(void (^ _Nonnull)(NSError * _Nullable, SocialRadioSocialCredentials * _Nullable))completion;
- (void)translateEndpointResponseWithEndpoint:(NSString * _Nullable)endpoint pathParameters:(NSDictionary<NSString *, NSString *> * _Nullable)pathParameters queryParameters:(NSArray<NSURLQueryItem *> * _Nullable)queryParameters body:(NSDictionary<NSString *, id> * _Nullable)body error:(NSError * _Nullable)error statusCode:(NSInteger)statusCode response:(id _Nullable)response responseData:(NSData * _Nullable)responseData httpsResponse:(NSHTTPURLResponse * _Nullable)httpsResponse completion:(void (^ _Nonnull)(NSError * _Nullable, NSInteger, id _Nullable, NSData * _Nullable))completion;
@end

@class SocialRadioConfig;
@protocol TunedRestDelegate;
@protocol SocialRadioStatusObserverDelegate;
@protocol SocialRadioUIDelegate;
@protocol SocialRadioStreamingDelegate;
@class UIViewController;
@class SocialRadioList;

/// SocialRadio represents the Radio SDK and exposes all its functionality. It follows a Singleton pattern.
SWIFT_CLASS("_TtC11SocialRadio11SocialRadio")
@interface SocialRadio : NSObject
/// Initialiser for Radio SDK to work against a Tuned Global’s Store and Tuned Global’s APIs.
/// This method takes in delegates to update the UI and feed access tokens to the Tuned Global’s APIs, as well as the ISO2 country code the device runs from and the Tuned Global Store ID.
/// \param config The SocialRadio configuration.
///
/// \param tunedRestDelegate The delegate in charge of feeding and renewing Tuned Global APIs access tokens. See TunedRestDelegate.
///
/// \param socialRadioStatusDelegate The delegate in charge of updating any UI with status updates from SocialRadio. See SocialRadioStatusObserverDelegate.
///
/// \param socialRadioUIDelegate The delegate in charge of presenting user interfaces the SocialRadio needs
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
+ (void)initialiseWithConfig:(SocialRadioConfig * _Nonnull)config tunedRestDelegate:(id <TunedRestDelegate> _Nonnull)tunedRestDelegate socialRadioStatusDelegate:(id <SocialRadioStatusObserverDelegate> _Nullable)socialRadioStatusDelegate socialRadioUIDelegate:(id <SocialRadioUIDelegate> _Nonnull)socialRadioUIDelegate completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Initialiser for Radio SDK to work against a custom backend and APIs.
/// This method takes in delegates to update the UI and feed access tokens to the Tuned Global’s APIs, as well as the ISO2 country code the device runs from and the Tuned Global Store ID.
/// \param config The SocialRadio configuration.
///
/// \param automixIQStreamingDelegate The delegate in charge of feeding all data and metadata the SocialRadio needs. See AutomixIQStreamingDelegate
///
/// \param socialRadioStreamingDelegate The delegate in charge of fetching artwork and recommendations for tracks
///
/// \param socialRadioStatusDelegate The delegate in charge of updating any UI with status updates from SocialRadio. See SocialRadioStatusObserverDelegate.
///
/// \param socialRadioUIDelegate The delegate in charge of presenting user interfaces the SocialRadio needs
///
/// \param socialBackendDelegate The delegate to enable log in and storing credentials for your custom social layer.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
+ (void)initialiseWithConfig:(SocialRadioConfig * _Nonnull)config automixIQStreamingDelegate:(id <AutomixIQStreamingDelegate> _Nonnull)automixIQStreamingDelegate socialRadioStreamingDelegate:(id <SocialRadioStreamingDelegate> _Nonnull)socialRadioStreamingDelegate socialRadioStatusDelegate:(id <SocialRadioStatusObserverDelegate> _Nullable)socialRadioStatusDelegate socialRadioUIDelegate:(id <SocialRadioUIDelegate> _Nonnull)socialRadioUIDelegate socialBackendDelegate:(id <SocialBackendDelegate> _Nonnull)socialBackendDelegate completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Terminates / deinitialises SocialRadio. Call this on applicationWillTerminate, or whenever you no longer need it.
- (void)terminate;
/// Returns the singleton instance.
///
/// returns:
/// The singleton instance.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) SocialRadio * _Nonnull instance;)
+ (SocialRadio * _Nonnull)instance SWIFT_WARN_UNUSED_RESULT;
/// Forces SocialRadio to ask its delegate for new credentials
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)forceRefreshCredentialsWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Clears AutomixIQ backing files and recreates them empty
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)clearCacheWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Adds a new status observer delegate
/// \param statusObserverDelegate The delegate to add.
///
- (void)addStatusObserverDelegate:(id <SocialRadioStatusObserverDelegate> _Nonnull)statusObserverDelegate;
/// Removes a status observer delegate
/// \param statusObserverDelegate The delegate to remove.
///
- (void)removeStatusObserverDelegate:(id <SocialRadioStatusObserverDelegate> _Nonnull)statusObserverDelegate;
/// Starts a Radio session in creation mode, with the tracks and metadata provided.
/// \param identifiers The list of track identifiers that form the playlist you are loading the player with.
///
/// \param metadata An array of TunedTrackModel objects you can pass to the engine so it doesn’t make additional API requests for the corresponding track identifiers metadata. Can be nil.
///
/// \param playTrackIndex The index of the track to begin playback at.
///
/// \param seconds The time within the selected track to begin playback at, in seconds.
///
/// \param autoplay If true, playback will start as soon as possible. Otherwise, playback will start only when calling -(void)play.
///
/// \param contextType A string representing the source of these tracks, for metrics purposes (‘playlist’, ‘album’, etc).
///
/// \param contextId The id of the source of these tracks, for metrics purposes.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// <li>
/// radioViewController: The uiviewcontroller displaying the UI
/// </li>
/// </ul>
///
///
- (void)startRadioSessionWithIdentifiers:(NSArray<NSString *> * _Nonnull)identifiers metadata:(NSArray<TunedTrackModel *> * _Nullable)metadata playTrackIndex:(int32_t)playTrackIndex seconds:(float)seconds autoplay:(BOOL)autoplay contextType:(NSString * _Nullable)contextType contextId:(NSString * _Nullable)contextId completion:(void (^ _Nullable)(NSError * _Nullable, UIViewController * _Nullable))completion;
/// Ends a Radio session. Be mindful if there is an ongoing Live radio show, this will terminate it without asking.
/// \param completion Code to be executed upon completing the asynchronous request.
///
- (void)endRadioSessionWithCompletion:(void (^ _Nullable)(void))completion;
/// Returns the view controller rendering the radio UI if either a creation or consumpsion session has already started.
/// In order to start a creation session, call startRadioSession()
/// In order top start a consumption session, call joinLiveBroadcast()
///
/// returns:
/// The view controller if a session has started, nil otherwise.
- (UIViewController * _Nullable)radioUIViewController SWIFT_WARN_UNUSED_RESULT;
/// Queries the live shows, paged.
/// \param limit The maximum number of live shows to get
///
/// \param start The start for this page
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// <li>
/// liveMixtapes: The live mixtapes
/// </li>
/// </ul>
///
///
- (void)getLiveBroadcastsWithLimit:(NSInteger)limit start:(NSString * _Nullable)start completion:(void (^ _Nonnull)(NSError * _Nullable, SocialRadioList * _Nullable))completion;
/// Submits a report for inappropriate content for a user.
/// \param identifier The identifier of the user to report
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)reportUserWithIdentifier:(NSString * _Nonnull)identifier completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Submits a report for inappropriate content for a mixtape.
/// \param identifier The identifier of the mixtape to report
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)reportMixtapeWithIdentifier:(NSString * _Nonnull)identifier completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Submits a request to notify all followers of a user of something.
/// \param userIdentifier The identifier of the user whose followers get notified
///
/// \param title The title of the notification
///
/// \param body The body of the notification
///
/// \param objectType The object type the notification refers to
///
/// \param objectId The object identifier the notification refers to
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)notifyFollowersWithUserIdentifier:(NSString * _Nonnull)userIdentifier title:(NSString * _Nonnull)title body:(NSString * _Nonnull)body objectType:(NSString * _Nonnull)objectType objectId:(NSString * _Nonnull)objectId completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Starts playing a live mixtape as a consumer
/// \param identifier The identifier of mixtape to join
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// <li>
/// radioViewController: The uiviewcontroller displaying the UI
/// </li>
/// </ul>
///
///
- (void)joinLiveBroadcastWithIdentifier:(NSString * _Nonnull)identifier completion:(void (^ _Nonnull)(NSError * _Nullable, UIViewController * _Nullable))completion;
/// Returns the initialised status of the Automix SDK.
/// <ul>
///   <li>
///     returns true if initialised, false otherwise.
///   </li>
/// </ul>
+ (BOOL)initialised SWIFT_WARN_UNUSED_RESULT;
/// Returns the on/off status of SocialRadio.
/// <ul>
///   <li>
///     returns true if on, false otherwise.
///   </li>
/// </ul>
- (BOOL)on SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class UIColor;
@class SocialRadioFeatureSetConfig;
@class SocialRadioUIConfig;

SWIFT_CLASS("_TtC11SocialRadio17SocialRadioConfig")
@interface SocialRadioConfig : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull apiKey;
@property (nonatomic, readonly, copy) NSString * _Nonnull country;
@property (nonatomic, readonly, copy) NSString * _Nonnull storeId;
@property (nonatomic, readonly, copy) NSString * _Nonnull applicationId;
+ (NSInteger)colorToIntWithColor:(UIColor * _Nonnull)color SWIFT_WARN_UNUSED_RESULT;
+ (UIColor * _Nonnull)intToColorWithColorInt:(NSInteger)colorInt SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithApiKey:(NSString * _Nonnull)apiKey country:(NSString * _Nonnull)country storeId:(NSString * _Nonnull)storeId applicationId:(NSString * _Nonnull)applicationId featureSetConfig:(SocialRadioFeatureSetConfig * _Nonnull)featureSetConfig uiConfig:(SocialRadioUIConfig * _Nonnull)uiConfig OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, strong) SocialRadioFeatureSetConfig * _Nonnull featureSetConfig;
@property (nonatomic, strong) SocialRadioUIConfig * _Nonnull uiConfig;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC11SocialRadio27SocialRadioFeatureSetConfig")
@interface SocialRadioFeatureSetConfig : NSObject
- (nonnull instancetype)initWithAllowFX:(BOOL)allowFX allowAudioEffects:(BOOL)allowAudioEffects allowBackgrounds:(BOOL)allowBackgrounds allowCommenting:(BOOL)allowCommenting allowVoiceOver:(BOOL)allowVoiceOver allowSongSuggestions:(BOOL)allowSongSuggestions allowInvites:(BOOL)allowInvites allowPublicBroadcasts:(BOOL)allowPublicBroadcasts allowStudio:(BOOL)allowStudio deeplinkToUser:(NSString * _Nonnull)deeplinkToUser maximumTimerStatusUpdatesPerSecond:(NSInteger)maximumTimerStatusUpdatesPerSecond OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic) BOOL allowFX;
@property (nonatomic) BOOL allowAudioEffects;
@property (nonatomic) BOOL allowBackgrounds;
@property (nonatomic) BOOL allowCommenting;
@property (nonatomic) BOOL allowVoiceOver;
@property (nonatomic) BOOL allowSongSuggestions;
@property (nonatomic) BOOL allowInvites;
@property (nonatomic) BOOL allowPublicBroadcasts;
@property (nonatomic) BOOL allowStudio;
@property (nonatomic, copy) NSString * _Nonnull deeplinkToUser;
@property (nonatomic) NSInteger maximumTimerStatusUpdatesPerSecond;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC11SocialRadio15SocialRadioList")
@interface SocialRadioList : NSObject
/// The list next item reference
- (NSString * _Nullable)listNext SWIFT_WARN_UNUSED_RESULT;
/// The list next item reference
- (NSString * _Nullable)listNextStart SWIFT_WARN_UNUSED_RESULT;
/// The list of items
- (NSArray * _Nullable)listItems SWIFT_WARN_UNUSED_RESULT;
/// The list total count
- (NSInteger)listTotal SWIFT_WARN_UNUSED_RESULT;
/// The list current limit
- (NSInteger)listLimit SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// SocialRadioLogLevel is an enum of all the AutomixIQ available log levels
/// \param logLevelTrace AutomixIQ logs with no filter
///
/// \param logLevelDebug AutomixIQ logs everything except low level details
///
/// \param logLevelInfo AutomixIQ logs everything except low level details and debug statements
///
/// \param logLevelWarning AutomixIQ only logs errors and warnings
///
/// \param logLevelError AutomixIQ only logs errors
///
/// \param logLevelFatal AutomixIQ only logs fatal errors
///
typedef SWIFT_ENUM(NSInteger, SocialRadioLogLevel, open) {
  SocialRadioLogLevelLogLevelTrace = 0,
  SocialRadioLogLevelLogLevelDebug = 1,
  SocialRadioLogLevelLogLevelInfo = 2,
  SocialRadioLogLevelLogLevelWarning = 3,
  SocialRadioLogLevelLogLevelError = 4,
  SocialRadioLogLevelLogLevelFatal = 5,
};

@class NSDate;
@class SocialRadioMixtapeTrack;
@class SocialRadioMixtapeCounters;
@class SocialRadioWaveformBlob;
@class SocialRadioMixtapeLite;

/// SocialRadioMixtape models a mixtape
SWIFT_CLASS("_TtC11SocialRadio18SocialRadioMixtape")
@interface SocialRadioMixtape : NSObject
/// The identifier for the mixtape
@property (nonatomic, readonly, copy) NSString * _Nullable id;
@property (nonatomic, copy) NSString * _Nullable mixId;
/// The url for its recipe
@property (nonatomic, copy) NSString * _Nullable href;
/// The title of this mixtape
@property (nonatomic, copy) NSString * _Nullable title;
/// The description of this mixtape
@property (nonatomic, copy) NSString * _Nullable descr;
/// The time this mixtape was created
@property (nonatomic, copy) NSDate * _Nullable created;
/// The time this mixtape was last updated
@property (nonatomic, copy) NSDate * _Nullable updated;
/// This mixtape’s tags
@property (nonatomic, copy) NSArray<NSString *> * _Nullable tags;
/// This mixtape’s tracks
@property (nonatomic, copy) NSArray<SocialRadioMixtapeTrack *> * _Nullable tracks;
/// This mixtape’s counters
@property (nonatomic, strong) SocialRadioMixtapeCounters * _Nullable counters;
/// The minimum version of the Pacemaker Engine that can play this mixtape
@property (nonatomic, copy) NSString * _Nullable minEngineVersion;
/// The waveform representation for this mixtape
@property (nonatomic, strong) SocialRadioWaveformBlob * _Nullable waveform;
/// The status of this mixtape, i.e. “posted”, “cocreation”, “live”, nil otherwise
@property (nonatomic, copy) NSString * _Nullable status;
/// The author of this mixtape
@property (nonatomic, strong) SocialRadioUser * _Nullable author;
/// The mixtape this was remixed from, nil if its an original
@property (nonatomic, strong) SocialRadioMixtapeLite * _Nullable originMix;
/// true if this mixtape was deleted, false otherwise
@property (nonatomic, copy) NSDate * _Nullable deleted;
/// The last time this mixtape was recommended
@property (nonatomic, copy) NSDate * _Nullable recommendedDate;
/// The list of cocreators for this mixtape
@property (nonatomic, copy) NSArray<SocialRadioUser *> * _Nullable cocreators;
/// The duration in seconds of this mixtape
@property (nonatomic, readonly) NSInteger mixLength;
/// True if this mixtape is a draft, false otherwise
@property (nonatomic, readonly) BOOL mixIsDraft;
/// True if this mixtape is liked by logged in user, false otherwise
@property (nonatomic, readonly) BOOL mixUserLikes;
/// true if this mixtape was created using the studio, false otherwise
@property (nonatomic, readonly) BOOL mixPlus;
/// true if this mixtape is live, false otherwise
@property (nonatomic, readonly) BOOL mixLive;
/// The hash opf this mixtape
@property (nonatomic, readonly) int64_t mixRecipeHash;
/// The last time this mixtpae was updated by anothe rcreator
@property (nonatomic, readonly) int64_t mixLastForeignUpdate;
/// true if there is at least one explicit track, false otherwise
@property (nonatomic, readonly) BOOL containsExplicitTracks;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// SocialRadioMixtapeCounters models the set of counters for information about a mixtape
SWIFT_CLASS("_TtC11SocialRadio26SocialRadioMixtapeCounters")
@interface SocialRadioMixtapeCounters : NSObject
/// The number of times this mixtape has been played
@property (nonatomic, readonly) NSInteger mixPlays;
/// The number of times this mixtape has been liked
@property (nonatomic, readonly) NSInteger mixLikes;
/// The number of times this mixtape has been remixed
@property (nonatomic, readonly) NSInteger mixRemixes;
/// The number of times this mixtape has been reposted
@property (nonatomic, readonly) NSInteger mixReposts;
/// The number of times this mixtape has been commented on
@property (nonatomic, readonly) NSInteger mixComments;
/// The depth of this mixtape in the remix tree of this mixtape
@property (nonatomic, readonly) NSInteger mixBranchDepth;
/// The position of this mixtape in the remix tree of this mixtape
@property (nonatomic, readonly) NSInteger mixBranchPosition;
/// The number of times this mixtape has been recommended
@property (nonatomic, readonly) NSInteger mixRecommendations;
/// The likelyhood this mixtape will be liked according to some ML model
@property (nonatomic, readonly) float mixMlScore;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// SocialRadioMixtapeLite models a mixtape with the minimum required fields
SWIFT_CLASS("_TtC11SocialRadio22SocialRadioMixtapeLite")
@interface SocialRadioMixtapeLite : NSObject
/// The identifier for the mixtape
@property (nonatomic, copy) NSString * _Nullable mixId;
/// The url for its recipe
@property (nonatomic, copy) NSString * _Nullable href;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class SocialRadioMixtapeTrackImage;

/// SocialRadioMixtapeTrack models a track in a mixtape
SWIFT_CLASS("_TtC11SocialRadio23SocialRadioMixtapeTrack")
@interface SocialRadioMixtapeTrack : NSObject
/// The identifier for the type of track
@property (nonatomic, copy) NSString * _Nullable service;
/// The identifier for the track
@property (nonatomic, copy) NSString * _Nullable trackRef;
/// The set of images available for this track
@property (nonatomic, copy) NSArray<SocialRadioMixtapeTrackImage *> * _Nullable images;
/// The significant color of the artwork of this track as a string representation
@property (nonatomic, copy) NSString * _Nullable color;
/// The artist name
@property (nonatomic, copy) NSString * _Nullable artist;
/// The title
@property (nonatomic, copy) NSString * _Nullable title;
/// A list of ISO2 country codes where the track is playable
@property (nonatomic, copy) NSArray<NSString *> * _Nullable availableMarkets;
/// The URL of a sample sound for this track a s a string
@property (nonatomic, copy) NSString * _Nullable previewURL;
/// The key of the track
@property (nonatomic, copy) NSString * _Nullable key;
/// The track duration
@property (nonatomic, readonly) int64_t trackDuration;
/// True if this track has explicit content, false otherwise
@property (nonatomic, readonly) BOOL trackExplicit;
/// The bpm of the track
@property (nonatomic, readonly) float trackBpm;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// SocialRadioMixtapeTrackImage models the image for a track in a mixtape
SWIFT_CLASS("_TtC11SocialRadio28SocialRadioMixtapeTrackImage")
@interface SocialRadioMixtapeTrackImage : NSObject
/// The url for the image
@property (nonatomic, copy) NSString * _Nullable url;
/// The height of the image
@property (nonatomic, readonly) NSInteger imageHeight;
/// The width of the image
@property (nonatomic, readonly) NSInteger imageWidth;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// SocialRadio playback mode
typedef SWIFT_ENUM(NSInteger, SocialRadioPlaybackMode, open) {
  SocialRadioPlaybackModeAutomix = 0,
  SocialRadioPlaybackModeLiveCreation = 1,
  SocialRadioPlaybackModeLiveConsumption = 2,
};


/// SocialRadioSocialCredentials models credentials to access social REST APIs.
SWIFT_CLASS("_TtC11SocialRadio28SocialRadioSocialCredentials")
@interface SocialRadioSocialCredentials : NSObject
/// The access token.
@property (nonatomic, copy) NSString * _Nullable accessToken;
/// The token type.
@property (nonatomic, copy) NSString * _Nullable tokenType;
/// The refresh token
@property (nonatomic, copy) NSString * _Nullable refreshToken;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum SocialRadioStatusVariable : NSInteger;

/// SocialRadioStatus models the State of the AutomixIQ during playback.
SWIFT_CLASS("_TtC11SocialRadio17SocialRadioStatus")
@interface SocialRadioStatus : NSObject <NSCopying>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
/// Represents if sound is playing from Automix SDK, true if it is, false otherwise.
@property (nonatomic) BOOL playing;
/// Represents if more than one track is concurrently playing from Automix SDK (mixing), true if it is, false otherwise.
@property (nonatomic) BOOL mixing;
/// Represents the identifier of the currently playing track if not mixing, the front track of the two mixed together if mixing. This would be the track a UI needs to show as playing or active.
@property (nonatomic, copy) NSString * _Nullable playingTrackIdentifier;
/// Represents the position of the currently playing track in the playlist if not mixing, the front track of the two mixed together if mixing. This would be the track a UI needs to show as playing or active.
/// If seeking, it reports seek landing track index until jump is complete. This should be use on the UI.
@property (nonatomic) NSInteger playingTrackIndex;
/// Represents the current playback time of the playing track. If seeking, it reports seek landing time until jump is complete. This should be use on the UI.
@property (nonatomic) NSTimeInterval playingTrackCurrentTime;
/// Represents the total playback time of the playing track.
@property (nonatomic) NSTimeInterval playingTrackTotalTime;
/// Represents the list of track identifiers in the order they will be played
@property (nonatomic, copy) NSArray<NSString *> * _Nonnull playlist;
/// Represents the tracks that failed loading for any reason
@property (nonatomic, copy) NSArray<NSString *> * _Nullable failedTrackLoadIdentifiers;
@property (nonatomic) BOOL explicitLyricsFiltering;
@property (nonatomic) int64_t mixId;
@property (nonatomic) NSInteger playbackMode;
+ (NSString * _Nonnull)socialRadioStatusVariableName:(enum SocialRadioStatusVariable)variable SWIFT_WARN_UNUSED_RESULT;
- (id _Nonnull)variableValue:(enum SocialRadioStatusVariable)variable SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_PROTOCOL("_TtP11SocialRadio33SocialRadioStatusObserverDelegate_")
@protocol SocialRadioStatusObserverDelegate <NSObject>
/// Called when the status of AutomixIQ changes
/// \param variables a list of AutomixIQStatusVariable that changed since last time this method was called, or since AutomixIQ was initialised.
///
/// \param status the current status of AutomixIQ
///
- (void)statusChangedWithVariables:(NSArray<NSNumber *> * _Nonnull)variables status:(SocialRadioStatus * _Nonnull)status;
@end

/// SocialRadio status variable type
typedef SWIFT_ENUM(NSInteger, SocialRadioStatusVariable, open) {
  SocialRadioStatusVariablePlaying = 0,
  SocialRadioStatusVariableMixing = 1,
  SocialRadioStatusVariablePlayingTrackIdentifier = 2,
  SocialRadioStatusVariablePlayingTrackIndex = 3,
  SocialRadioStatusVariablePlayingTrackCurrentTime = 4,
  SocialRadioStatusVariablePlayingTrackTotalTime = 5,
  SocialRadioStatusVariablePlaylist = 6,
  SocialRadioStatusVariableFailedTrackLoadIdentifiers = 7,
  SocialRadioStatusVariableExplicitLyricsFiltering = 8,
  SocialRadioStatusVariableMixId = 9,
  SocialRadioStatusVariablePlaybackMode = 10,
};


/// SocialRadioStreamingDelegate protocol defines the methods to be implemented with providing SocialRadio the information it requires to display content and get recommendations.
SWIFT_PROTOCOL("_TtP11SocialRadio28SocialRadioStreamingDelegate_")
@protocol SocialRadioStreamingDelegate <NSObject>
/// Called by the AutomixIQ SDK when it needs the URL for thumbor. Return nil on completion if there is none
/// \param completion Code to be executed upon completing the asynchronous request
///
/// \a completion parameters:
/// <ul>
/// <li>
/// url: the thumbor url as a string if available.
/// </li>
/// </ul>
///
///
- (void)asyncGetThumborLocationWithCompletion:(void (^ _Nonnull)(NSString * _Nullable))completion;
/// Called by the AutomixIQ SDK when it needs tracks recommendations based on a set of identifiers
/// \param identifiers Set of track identifiers to base the recommendations on
///
/// \param limit Number of recommendations to get
///
/// \param contextIds The ids of tracks providing cotext to the recomendations
///
/// \param completion Code to be executed upon completing the asynchronous request
///
/// \a completion parameters:
/// <ul>
/// <li>
/// tracks: the tracks recommendations.
/// </li>
/// </ul>
///
///
- (void)asyncGetTrackRecommendationsWithIdentifiers:(NSArray<NSString *> * _Nonnull)identifiers contextIds:(NSArray<NSString *> * _Nullable)contextIds limit:(NSInteger)limit completion:(void (^ _Nonnull)(NSArray<TunedTrackModel *> * _Nullable))completion;
@end


SWIFT_CLASS("_TtC11SocialRadio19SocialRadioUIConfig")
@interface SocialRadioUIConfig : NSObject
- (nonnull instancetype)initWithFontFamily:(NSString * _Nonnull)fontFamily titleFontSize:(NSInteger)titleFontSize radioUIFontSizeHuge:(NSInteger)radioUIFontSizeHuge radioUIFontSizeLarge:(NSInteger)radioUIFontSizeLarge radioUIFontSizeRegular:(NSInteger)radioUIFontSizeRegular radioUIFontSizeSmall:(NSInteger)radioUIFontSizeSmall radioUIFontSizeTiny:(NSInteger)radioUIFontSizeTiny radioUIFontSizeMatchMachine:(NSInteger)radioUIFontSizeMatchMachine textFieldFontBold:(BOOL)textFieldFontBold textFieldBackgroundColor:(UIColor * _Nonnull)textFieldBackgroundColor textFieldBorderRadius:(float)textFieldBorderRadius textFieldTextColor:(UIColor * _Nonnull)textFieldTextColor textFieldPlaceholderTextColor:(UIColor * _Nonnull)textFieldPlaceholderTextColor dialogTitleFontBold:(BOOL)dialogTitleFontBold dialogTitleTextColor:(UIColor * _Nonnull)dialogTitleTextColor dialogDescriptionFontBold:(BOOL)dialogDescriptionFontBold dialogDescriptionTextColor:(UIColor * _Nonnull)dialogDescriptionTextColor dialogPrimaryButtonFontBold:(BOOL)dialogPrimaryButtonFontBold dialogPrimaryButtonBackgroundColor:(UIColor * _Nonnull)dialogPrimaryButtonBackgroundColor dialogPrimaryButtonBorderRadius:(float)dialogPrimaryButtonBorderRadius dialogPrimaryButtonTextColor:(UIColor * _Nonnull)dialogPrimaryButtonTextColor dialogPrimaryButtonBorder:(BOOL)dialogPrimaryButtonBorder dialogPrimaryButtonBorderColor:(UIColor * _Nonnull)dialogPrimaryButtonBorderColor dialogSecondaryButtonFontBold:(BOOL)dialogSecondaryButtonFontBold dialogSecondaryButtonBackgroundColor:(UIColor * _Nonnull)dialogSecondaryButtonBackgroundColor dialogSecondaryButtonBorderRadius:(float)dialogSecondaryButtonBorderRadius dialogSecondaryButtonTextColor:(UIColor * _Nonnull)dialogSecondaryButtonTextColor dialogSecondaryButtonBorder:(BOOL)dialogSecondaryButtonBorder dialogSecondaryButtonBorderColor:(UIColor * _Nonnull)dialogSecondaryButtonBorderColor OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nullable fontFamily;
@property (nonatomic) NSInteger titleFontSize;
@property (nonatomic) NSInteger radioUIFontSizeHuge;
@property (nonatomic) NSInteger radioUIFontSizeLarge;
@property (nonatomic) NSInteger radioUIFontSizeRegular;
@property (nonatomic) NSInteger radioUIFontSizeSmall;
@property (nonatomic) NSInteger radioUIFontSizeTiny;
@property (nonatomic) NSInteger radioUIFontSizeMatchMachine;
@property (nonatomic) BOOL textFieldFontBold;
@property (nonatomic, strong) UIColor * _Nonnull textFieldBackgroundColor;
@property (nonatomic) float textFieldBorderRadius;
@property (nonatomic, strong) UIColor * _Nonnull textFieldTextColor;
@property (nonatomic, strong) UIColor * _Nonnull textFieldPlaceholderTextColor;
@property (nonatomic) BOOL dialogTitleFontBold;
@property (nonatomic, strong) UIColor * _Nonnull dialogTitleTextColor;
@property (nonatomic) BOOL dialogDescriptionFontBold;
@property (nonatomic, strong) UIColor * _Nonnull dialogDescriptionTextColor;
@property (nonatomic) BOOL dialogPrimaryButtonFontBold;
@property (nonatomic, strong) UIColor * _Nonnull dialogPrimaryButtonBackgroundColor;
@property (nonatomic) float dialogPrimaryButtonBorderRadius;
@property (nonatomic, strong) UIColor * _Nonnull dialogPrimaryButtonTextColor;
@property (nonatomic) BOOL dialogPrimaryButtonBorder;
@property (nonatomic, strong) UIColor * _Nonnull dialogPrimaryButtonBorderColor;
@property (nonatomic) BOOL dialogSecondaryButtonFontBold;
@property (nonatomic, strong) UIColor * _Nonnull dialogSecondaryButtonBackgroundColor;
@property (nonatomic) float dialogSecondaryButtonBorderRadius;
@property (nonatomic, strong) UIColor * _Nonnull dialogSecondaryButtonTextColor;
@property (nonatomic) BOOL dialogSecondaryButtonBorder;
@property (nonatomic, strong) UIColor * _Nonnull dialogSecondaryButtonBorderColor;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// SocialRadioUIDelegate protocol defines the methods to be implemented by a class tasked with providing the Automix SDK the user interface requires for social features.
SWIFT_PROTOCOL("_TtP11SocialRadio21SocialRadioUIDelegate_")
@protocol SocialRadioUIDelegate
/// Called by SocialRadio when it wishes to present UI to select one or many tracks
/// \param filterOutExplicitContent true if you need to not present explicit content, false otherwise
///
/// \param completion Code to be run when the user interaction ends and the view is dismissed.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// tracks: the tracks that were selected
/// </li>
/// <li>
/// contextType: A string representing the source of these tracks, for logging purposes (‘playlist’, ‘album’, etc).
/// </li>
/// <li>
/// contextId: The id of the source of these tracks, for logging purposes.
/// </li>
/// <li>
/// playlistName: the name of the playlist that was selected
/// </li>
/// </ul>
///
///
- (void)presentTracklistWithFilterOutExplicitContent:(BOOL)filterOutExplicitContent completion:(void (^ _Nonnull)(NSArray<TunedTrackModel *> * _Nullable, NSString * _Nullable, NSString * _Nullable, NSString * _Nullable))completion;
@optional
/// Called by SocialRadio when it wishes to present UI to authenticate a user
/// \param completion Code to be run when the user interaction ends and the view is dismissed.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// success: true is logged in, false otherwise
/// </li>
/// </ul>
///
///
- (void)presentAuthenticationWithCompletion:(void (^ _Nonnull)(BOOL))completion;
@required
/// Called by SocialRadio when it wishes to present UI with a user’s information
/// \param identifier The identifier of the user.
///
/// \param completion Code to be run when the user interaction ends and the view is dismissed.
///
- (void)presentProfileWithIdentifier:(NSString * _Nullable)identifier completion:(void (^ _Nonnull)(void))completion;
/// Called by SocialRadio when it needs to know wether a track is liked or not
/// \param identifier The identifier of the track.
///
/// \param completion Code to be run when the user interaction ends and the view is dismissed.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// isLiked: true if the track is liked, false otherwise
/// </li>
/// </ul>
///
///
- (void)isTrackLikedWithIdentifier:(NSString * _Nonnull)identifier completion:(void (^ _Nonnull)(BOOL))completion;
/// Called by SocialRadio when it needs add or remove a track with a given identifier from liked
/// \param identifier The identifier of the track.
///
/// \param liked true if we want the track liked, false otherwise.
///
/// \param completion Code to be run when the operation completes.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: the error on the operation, nil if successful
/// </li>
/// <li>
/// success: true if the operation was successful, false otherwise
/// </li>
/// </ul>
///
///
- (void)setTrackLikedWithIdentifier:(NSString * _Nonnull)identifier liked:(BOOL)liked completion:(void (^ _Nonnull)(NSError * _Nullable, BOOL))completion;
@optional
/// Called by SocialRadio when the Radio UI is dismissed
- (void)didDismissRadioUIWithUserInitiated:(BOOL)userInitiated;
/// Called by SocialRadio when the Radio UI about to be dismissed
- (void)willDismissRadioUIWithUserInitiated:(BOOL)userInitiated;
/// Called by SocialRadio when the Radio UI is closed
- (void)didCloseRadioUIWithUserInitiated:(BOOL)userInitiated;
/// Called by SocialRadio when the Radio UI is closed
- (void)willCloseRadioUIWithUserInitiated:(BOOL)userInitiated;
@end


/// SocialRadioUser models a user
SWIFT_CLASS("_TtC11SocialRadio15SocialRadioUser")
@interface SocialRadioUser : NSObject
/// The identifier for the user
@property (nonatomic, copy) NSString * _Nullable userId;
/// The user’s alias
@property (nonatomic, copy) NSString * _Nullable alias;
/// The user’s avatar URL
@property (nonatomic, copy) NSString * _Nullable userThumbnail;
/// The user’s followers
@property (nonatomic, readonly) NSInteger userFollowers;
/// The user’s following
@property (nonatomic, readonly) NSInteger userFollowing;
/// The user’s mix count
@property (nonatomic, readonly) NSInteger userMixCount;
/// true if this is a paying user, false otherwise
@property (nonatomic, readonly) BOOL userPlus;
/// True if loggedInUser follows this guy, false otherwise
@property (nonatomic, readonly) BOOL isUserFollowing;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// SocialRadioWaveformBlob models the data to create a waveform shape representing a track
SWIFT_CLASS("_TtC11SocialRadio23SocialRadioWaveformBlob")
@interface SocialRadioWaveformBlob : NSObject
/// That data
@property (nonatomic, copy) NSString * _Nullable blob;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// TunedArtistModel models an artist.
SWIFT_CLASS("_TtC11SocialRadio16TunedArtistModel")
@interface TunedArtistModel : NSObject
/// The artist name.
@property (nonatomic, copy) NSString * _Nullable Name;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// TunedAuthenticationResponse models the response of a Tuned OAuth request
SWIFT_CLASS("_TtC11SocialRadio27TunedAuthenticationResponse")
@interface TunedAuthenticationResponse : NSObject
/// The access token
@property (nonatomic, copy) NSString * _Nullable access_token;
/// The token type
@property (nonatomic, copy) NSString * _Nullable token_type;
/// The refresh token
@property (nonatomic, copy) NSString * _Nullable refresh_token;
/// The Id of the authenticated user in Tuned Global’s backend
@property (nonatomic, copy) NSString * _Nullable tuned_user_id;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// AutomixIQ playback mode
typedef SWIFT_ENUM(NSInteger, TunedAutomixPlaybackMode, open) {
  TunedAutomixPlaybackModeAutomix = 0,
  TunedAutomixPlaybackModeLiveCreation = 1,
  TunedAutomixPlaybackModeLiveConsumption = 2,
};

/// TunedLogLevel is an enum of all the AutomixIQ available log levels
/// \param logLevelTrace AutomixIQ logs with no filter
///
/// \param logLevelDebug AutomixIQ logs everything except low level details
///
/// \param logLevelInfo AutomixIQ logs everything except low level details and debug statements
///
/// \param logLevelWarning AutomixIQ only logs errors and warnings
///
/// \param logLevelError AutomixIQ only logs errors
///
/// \param logLevelFatal AutomixIQ only logs fatal errors
///
typedef SWIFT_ENUM(NSInteger, TunedLogLevel, open) {
  TunedLogLevelLogLevelTrace = 0,
  TunedLogLevelLogLevelDebug = 1,
  TunedLogLevelLogLevelInfo = 2,
  TunedLogLevelLogLevelWarning = 3,
  TunedLogLevelLogLevelError = 4,
  TunedLogLevelLogLevelFatal = 5,
};


/// TunedPluginMetadataModel models metadata of a track traditionally obtained by running plugins on it. Key and BPM are recommented for best mixing.
/// The Type entry for bpm and key are “key” and “bpm” (case sensitive) respectively, the values need to be formatted as strings, and the key needs to be in OpenKey format.
SWIFT_CLASS("_TtC11SocialRadio24TunedPluginMetadataModel")
@interface TunedPluginMetadataModel : NSObject
/// The Type of metadata described by this object, examples: “key”, “bpm”
@property (nonatomic, copy) NSString * _Nullable Type;
/// The value of the metadata
@property (nonatomic, copy) NSString * _Nullable Meta;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// TunedRestDelegate protocol defines the methods to be implemented that will provide AutomixIQ the credentials and identifiers to Tuned Global’s backend
SWIFT_PROTOCOL("_TtP11SocialRadio17TunedRestDelegate_")
@protocol TunedRestDelegate <NSObject>
/// Called by AutomixIQ when initialised against a Tuned Global backend or when its access token has expired.
/// \param deviceIdentifierForVendor The unique identifier of the device.
///
/// \param countryCode The ISO2 code of the country the device is located.
///
/// \param tunedUserId The user’s id within the Tuned Global backend.
///
/// \param oldAccessToken The expired access token.
///
/// \param refreshToken The refresh token.
///
/// \param tokenType The token type.
///
/// \param completion Code to be executed upon completing the asynchronous request
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// <li>
/// credentials: The refreshed credentials
/// </li>
/// <li>
/// tunedUserId: The user’s id within the Tuned Global backend.
/// </li>
/// </ul>
///
///
- (void)tunedRestTokenExpiredWithDeviceIdentifierForVendor:(NSString * _Nonnull)deviceIdentifierForVendor countryCode:(NSString * _Nonnull)countryCode tunedUserId:(NSString * _Nullable)tunedUserId oldAccessToken:(NSString * _Nullable)oldAccessToken refreshToken:(NSString * _Nullable)refreshToken tokenType:(NSString * _Nullable)tokenType completion:(void (^ _Nonnull)(NSError * _Nullable, TunedAuthenticationResponse * _Nullable, NSString * _Nullable))completion;
@optional
/// Called by AutomixIQ while initialising to give you an opportunity to provide the authenticated device ID or perform device authentication as required.
/// If not implemented, AutomixIQ will proceed to register a device for the logged in user with deviceType: “iPhone”, displayName: “AutomixIQ” and deviceOS: “iOS”.
/// \param deviceIdentifierForVendor The unique identifier of the device
///
/// \param completion Code to be executed upon completing the asynchronous request
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// <li>
/// tunedDeviceId: The device id within the Tuned Global backend as a String, nil if there was an error.
/// </li>
/// </ul>
///
///
- (void)asyncGetAuthenticatedDeviceWithDeviceIdentifierForVendor:(NSString * _Nonnull)deviceIdentifierForVendor completion:(void (^ _Nonnull)(NSError * _Nullable, NSString * _Nullable))completion;
@required
/// Called by AutomixIQ to request the unique identifier for the users device as a string.
/// On iOS this is generally the Identifier for Vendor.
/// It can be any string as long as it is unique
/// AutomixIQ will use this string as the UniqueId if it needs to register the device for playback
///
/// returns:
/// The unique device identifier as string
- (NSString * _Nonnull)uniqueDeviceIdentifier SWIFT_WARN_UNUSED_RESULT;
/// Called by AutomixIQ to learn if it should log playback events to Tuned’s backend on your behalf or if you will implement logging yourself.
///
/// returns:
/// true if AutomixIQ is to log playback events automatically, false if you take the responsibility of logging playback events yourself.
- (BOOL)automaticallyLogPlayback SWIFT_WARN_UNUSED_RESULT;
@optional
/// Called by AutomixIQ when it wishes to output a log message
/// \param logLevel The log level.
///
/// \param message The message it wishes to log.
///
- (void)logAutomixIQMessageWithLogLevel:(enum TunedLogLevel)logLevel message:(NSString * _Nonnull)message;
@end


/// TunedTrackModel models a track. This metadata is required.
SWIFT_CLASS("_TtC11SocialRadio15TunedTrackModel")
@interface TunedTrackModel : NSObject
/// The artists of a track - the first one is the one to be presented by a UI
@property (nonatomic, copy) NSArray<TunedArtistModel *> * _Nullable Artists;
/// The title of a track
@property (nonatomic, copy) NSString * _Nullable Name;
/// The name of the album this track belongs to
@property (nonatomic, copy) NSString * _Nullable ReleaseName;
/// Objective-C accessible member for the track identifier as String
@property (nonatomic, copy) NSString * _Nonnull trackIdentifier;
/// Objective-C accessible member for the track number
@property (nonatomic) NSInteger trackNumber;
/// Objective-C accessible member for the track duration
@property (nonatomic) NSInteger duration;
/// Objective-C accessible member for the key, nil if unavailable
@property (nonatomic, readonly, copy) NSString * _Nullable key;
/// Objective-C accessible member for IsExplicit
@property (nonatomic) BOOL isExplicit;
/// Objective-C accessible member for the bpm, 09 if unavailable
@property (nonatomic, readonly) double bpm;
/// The url of the artwork image for this track as a String
@property (nonatomic, copy) NSString * _Nullable Image;
/// Initialises a Track Model
/// \param trackId The identifier of the track
///
/// \param artistName The name of the main artist of the track
///
/// \param name The title of the track
///
/// \param duration The track duration in seconds
///
/// \param isExplicit true if the track contains explicit lyrics, false otherwise
///
/// \param trackNumber The index of the track in the album it was released in
///
/// \param releaseName The nemae of the release this track’s in
///
/// \param key The key of this track as a String in Camelot format, i.e. 8m, nil if unavailable
///
/// \param tempo The bpm of this track as a float
///
/// \param image The url of the artwork image for this track as a String
///
- (nonnull instancetype)initWithTrackId:(NSString * _Nonnull)trackId artistName:(NSString * _Nonnull)artistName name:(NSString * _Nonnull)name duration:(NSInteger)duration isExplicit:(BOOL)isExplicit trackNumber:(NSInteger)trackNumber releaseName:(NSString * _Nonnull)releaseName key:(NSString * _Nullable)key tempo:(float)tempo image:(NSString * _Nullable)image OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end







typedef SWIFT_ENUM(NSInteger, _HMACAlgorithm, open) {
  _HMACAlgorithmMD5 = 0,
  _HMACAlgorithmSHA1 = 1,
  _HMACAlgorithmSHA224 = 2,
  _HMACAlgorithmSHA256 = 3,
  _HMACAlgorithmSHA384 = 4,
  _HMACAlgorithmSHA512 = 5,
};

#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
