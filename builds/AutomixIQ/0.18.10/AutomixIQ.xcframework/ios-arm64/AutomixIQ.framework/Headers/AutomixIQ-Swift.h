#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
#ifndef AUTOMIXIQ_SWIFT_H
#define AUTOMIXIQ_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wnon-modular-include-in-framework-module"
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#pragma clang diagnostic pop
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="AutomixIQ",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)
enum ErrorCode : NSInteger;
@class NSError;
@class NSString;
@class AutomixIQConfig;
@protocol TunedRestDelegate;
@protocol AutomixIQStatusObserverDelegate;
@protocol AutomixIQMusicCacheDelegate;
@protocol AutomixIQStreamingDelegate;
@class TunedTrackModel;
@class AutomixIQStatus;
@class TunedAdModel;
@class AutomixIQWaveformModel;

/// AutomixIQ represents the AutomixIQ SDK and exposes all its functionality. It follows a Singleton pattern.
SWIFT_CLASS("_TtC9AutomixIQ9AutomixIQ")
@interface AutomixIQ : NSObject
+ (NSError * _Nonnull)automixIQErrorWithCode:(enum ErrorCode)code SWIFT_WARN_UNUSED_RESULT;
+ (NSString * _Nullable)errorDescriptionWithCode:(enum ErrorCode)code SWIFT_WARN_UNUSED_RESULT;
/// Returns whether or not AutomixIQ is initialised.
/// <ul>
///   <li>
///     returns true if initialised, false otherwise.
///   </li>
/// </ul>
+ (BOOL)initialised SWIFT_WARN_UNUSED_RESULT;
/// Initialiser for AutomixIQ to work against a Tuned Global backend
/// This method takes in delegates to update the UI and feed OAuth2 access tokens to the Tuned Global APIs, as well as the ISO2 country code the device runs from and the Tuned Global Store ID.
/// \param config The AutomixIQ Configuration
///
/// \param tunedRestDelegate The delegate in charge of feeding and renewing Tuned Global OAuth2 access tokens. See TunedRestDelegate.
///
/// \param automixIQStatusDelegate The delegate in charge of updating any UI with status updates from AutomixIQ. See AutomixIQStatusObserverDelegate.
///
/// \param musicCacheDelegate The delegate in charge of saving and feeding in cached music to and from AutomixIQ
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
+ (void)initialiseWithConfig:(AutomixIQConfig * _Nonnull)config tunedRestDelegate:(id <TunedRestDelegate> _Nonnull)tunedRestDelegate automixIQStatusDelegate:(id <AutomixIQStatusObserverDelegate> _Nullable)automixIQStatusDelegate musicCacheDelegate:(id <AutomixIQMusicCacheDelegate> _Nullable)musicCacheDelegate completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Initialiser for AutomixIQ to work against any custom set of APIs.
/// This method takes in delegates to update the UI and feeds all data and metadata the AutomixIQ needs.
/// \param config The AutomixIQ Configuration
///
/// \param automixIQStreamingDelegate The delegate in charge of feeding all data and metadata the AutomixIQ needs. See AutomixIQStreamingDelegate.
///
/// \param automixIQStatusDelegate The delegate in charge of updating any UI with status updates from AutomixIQ. See AutomixIQStatusObserverDelegate.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
+ (void)initialiseWithConfig:(AutomixIQConfig * _Nonnull)config automixIQStreamingDelegate:(id <AutomixIQStreamingDelegate> _Nonnull)automixIQStreamingDelegate automixIQStatusDelegate:(id <AutomixIQStatusObserverDelegate> _Nullable)automixIQStatusDelegate completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Returns whether AutomixIQ can see the internet
///
/// returns:
/// true if internet is available, false otherwise
+ (BOOL)internetAvailable SWIFT_WARN_UNUSED_RESULT;
/// Terminates / deinitialises AutomixIQ. Call this on applicationWillTerminate, or whenever you no longer need it.
- (void)terminate;
/// Returns the singleton instance.
///
/// returns:
/// The singleton instance.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) AutomixIQ * _Nonnull instance;)
+ (AutomixIQ * _Nonnull)instance SWIFT_WARN_UNUSED_RESULT;
/// Forces AutomixIQ to ask its delegate for new credentials
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)forceRefreshCredentialsWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Clears AutomixIQ backing files and recreates them empty
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)clearCacheWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Adds a new music cache delegate
/// \param musicCacheDelegate The delegate to add.
///
- (void)setMusicCacheDelegate:(id <AutomixIQMusicCacheDelegate> _Nonnull)musicCacheDelegate;
/// Adds a new status observer delegate
/// \param statusObserverDelegate The delegate to add.
///
- (void)addStatusObserverDelegate:(id <AutomixIQStatusObserverDelegate> _Nonnull)statusObserverDelegate;
/// Removes a status observer delegate
/// \param statusObserverDelegate The delegate to remove.
///
- (void)removeStatusObserverDelegate:(id <AutomixIQStatusObserverDelegate> _Nonnull)statusObserverDelegate;
/// Turns AutomixIQ on.
/// Returns an error if the engine has not been initialised or has already been turned on.
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)automixOnCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Turns the AutomixIQ player on and starts playback if required as soon as possible at a given track and playback time within the provided playlist.
/// If the playlist is empty this operation will fail and AutomixIQ will be turned off.
/// Returns an error if the engine has not been initialised or has already been turned on.
/// \param identifiers The list of track identifiers that form the playlist you are loading the player with.
///
/// \param metadata An array of TunedTrackModel objects you can pass to the engine so it doesn’t make additional API requests for the corresponding track identifiers metadata. Can be nil.
///
/// \param playTrackIndex The index of the track to begin playback at.
///
/// \param seconds The time within the selected track to begin playback at, in seconds.
///
/// \param autoplay If true, playback will start as soon as possible. Otherwise, playback will start only when calling -(void)play.
///
/// \param contextType A string representing the source of these tracks, for logging purposes (‘playlist’, ‘album’, etc).
///
/// \param contextId The id of the source of these tracks, for logging purposes.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)automixOnIdentifiers:(NSArray<NSString *> * _Nonnull)identifiers metadata:(NSArray<TunedTrackModel *> * _Nullable)metadata playTrackIndex:(int32_t)playTrackIndex seconds:(float)seconds autoplay:(BOOL)autoplay contextType:(NSString * _Nullable)contextType contextId:(int32_t)contextId completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Turns the AutomixIQ player off.
/// In order to turn it back on you will have to call -(void)automixOnWithIdentifiers:playTrackIndex:seconds:autoplay:
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// <li>
/// status: The AutomixIQ SDK status when the off command was issued, in case you want to restore it elsewhere.
/// </li>
/// </ul>
///
///
- (void)automixOffWithCompletion:(void (^ _Nullable)(NSError * _Nullable, AutomixIQStatus * _Nonnull))completion;
/// Clears all the tracks in the AutomixIQ playlist
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)resetPlaylistToEmptyWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Loads a new playlist into AutomixIQ
/// Returns an error if the playlist is empty this opperation will fail and AutomixIQ will be turned off.
/// This will stop playback of the currently playing playlist and start the newly loaded one.
/// \param identifiers The list of track identifiers that form the playlist you are loading.
///
/// \param metadata An array of TunedTrackModel objects you can pass to the engine so it doesn’t make additional API requests for the corresponding track identifiers metadata. Can be nil.
///
/// \param playTrackIndex The index of the track to begin playback at.
///
/// \param seconds The time within the selected track to begin playback at, in seconds.
///
/// \param autoplay If true, playback will start as soon as possible. Otherwise, playback will start only when calling -(void)play.
///
/// \param contextType A string representing the source of these tracks, for logging purposes (‘playlist’, ‘album’, etc).
///
/// \param contextId The id of the source of these tracks, for logging purposes.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)loadTracksWithIdentifiers:(NSArray<NSString *> * _Nonnull)identifiers metadata:(NSArray<TunedTrackModel *> * _Nullable)metadata playTrackIndex:(int32_t)playTrackIndex seconds:(float)seconds autoplay:(BOOL)autoplay contextType:(NSString * _Nullable)contextType contextId:(int32_t)contextId completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Adds additional tracks to the playlist in AutomixIQ at a given index.
/// Returns an erorr if the index is out of bounds.
/// \param identifiers The list of track identifiers to add.
///
/// \param metadata An array of TunedTrackModel objects you can pass to the engine so it doesn’t make additional API requests for the corresponding track identifiers metadata. Can be nil.
///
/// \param contextType A string representing the source of these tracks, for logging purposes (‘playlist’, ‘album’, etc).
///
/// \param contextId The id of the source of these tracks, for logging purposes.
///
/// \param index The index at which this track will be added. If index == 0, it will be the first track of the playlist. If index == playlist.size() the track will be added last. If inbetween, it’ll push tracks from the index onwards back in the playlist to make room.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)addTracksWithIdentifiers:(NSArray<NSString *> * _Nonnull)identifiers metadata:(NSArray<TunedTrackModel *> * _Nullable)metadata contextType:(NSString * _Nullable)contextType contextId:(int32_t)contextId index:(int32_t)index completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Adds a single track to the AutomixIQ playlist at a given index.
/// Returns an erorr if the index is out of bounds.
/// \param identifier The track identifier to be added.
///
/// \param metadata TunedTrackModel object you can pass to the engine so it doesn’t make additional API requests for the corresponding track identifier metadata. Can be nil.
///
/// \param contextType A string representing the source of these tracks, for logging purposes (‘playlist’, ‘album’, etc).
///
/// \param contextId The id of the source of these tracks, for logging purposes.
///
/// \param index The index at which this track will be added. If index == 0, it will be the first track of the playlist. If index == playlist.size() the track will be added last. If inbetween, it’ll push tracks from the index onwards back in the playlist to make room.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)addTrackWithIdentifier:(NSString * _Nonnull)identifier metadata:(TunedTrackModel * _Nullable)metadata contextType:(NSString * _Nullable)contextType contextId:(int32_t)contextId index:(int32_t)index completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Removes a track at a given index in the AutomixIQ playlist.
/// Returns an erorr if the index is out of bounds.
/// \param index The index to remove.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)removeTrackAt:(int32_t)index completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Moves the track from one index to a different index.
/// \param index Index of the track to move
///
/// \param toIndex Index where it will land
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)moveTrackAt:(int32_t)index toIndex:(int32_t)toIndex completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Ads Ad(s) right after the currently playing index.
/// \param metadata The metadata of the Ads.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)addAdsWithMetadata:(NSArray<TunedAdModel *> * _Nonnull)metadata completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Removes existing Ad(s) if not currently playing one.
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)clearAdsWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Starts playback if paused.
/// Returns an error if the player is already playing.
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)playWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Pauses playback if playing.
/// Returns an error if the player is already paused.
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)pauseWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Moves the player to the beginning of the next track
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)nextWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Moves the player to the beginning of the previous track
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)previousWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Moves the player to the beginning of the current track
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)backWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// If on, after a playlist is done it restarts. Otherwise, it pauses.
/// This defaults to false on initialisation and should be set to match the state of the consumer’s UI
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)toggleReplayWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion SWIFT_DEPRECATED_MSG("Toggles are evil, please use setReplay(on:completion:)");
/// Tells AutomixIQ whether or not it should restart the playlist when reaching the end.
/// If on then playback will restart at the beginning otherwise it pauses at the end.
/// \param on true if you want replay, false otherwise.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)setReplayOn:(BOOL)on completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Jumps playback on the current track to the desired timestamp as soon as possible.
/// This will mix the track with itself so the seek is beat-matched and as seamless as possible, which means the landing position will be close but not exactly the fed timestamp.
/// \param seconds The timestamp to seek to.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)seekToSeconds:(float)seconds completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Jumps playback to the beginning of the track at the desired index as soon as possible.
/// \param index the index of the track to jump to
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
- (void)skipToTrackAtIndex:(NSInteger)index completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Sets the filter explicit lyrics flag.
/// When set to on, AutomixIQ will skip over the tracks that have the explicit content flag set in their metadata by mixing the currently playing track with the first available non-explicit track in the queue.
/// \param filterExplicit value to set, true if you wish for explicit tracks to not play, false otherwise.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)setFilterExplicitWithFilterExplicit:(BOOL)filterExplicit completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Sets a new order to the playlist while continuing to play the current track
/// \param newOrder The new ordered playlist whose items need to match the existing playlist.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)reorderTracksWithNewOrder:(NSArray<NSString *> * _Nonnull)newOrder completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Makes AutomixIQ play a given track until the end and then pause.
/// This is useful if you need to play any other content between tracks such as advertisements.
/// Returns an error if you call this on the last track’
/// \param enabled true if we need this track to play to the end then pause, false if we want to disable it
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)playTrackUntilEndThenPause:(BOOL)enabled completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Sets AutomixIQ’s play speed to a given value between 0.5 and 2, where 0.5 is half speed and 2 is double speed.
/// \param playSpeed The play speed to set
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)setAutomixPlaySpeed:(float)playSpeed completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Sets AutomixIQ’s volume to a given value between 0 and 1. If muted, calling this will cause AutomixIQ to unmute.
/// \param volumeNormalised The volume value to set
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)setAutomixVolumeNormalised:(float)volumeNormalised completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Toggles the AutomixIQ SDK mute
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)toggleMuteWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion SWIFT_DEPRECATED_MSG("Toggles are evil, please use setMute(on:completion:)");
/// Mutes AutomixIQ
/// \param on true to mute AutomixIQ, false otherwise.
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)setMuteOn:(BOOL)on completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Sets AutomixIQ’s preferred transition duration - transitions will not be exactly this duration but AutomixIQ will favour transitions with duration close to this one.
/// Setting it to 0 disables this hint and allows the engine to select the transition duration based on trained genre-based transition data.
/// \param duration The desired transition duration in seconds
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)setPreferredTransitionDurationSeconds:(float)duration completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Makes AutomixIQ repeat the currently playing track.
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)loopPlayingTrackWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Makes AutomixIQ stop repeating the currently playing track.
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)stopLoopingPlayingTrackWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Enables / Disables vinyl pause sound effect.
/// \param enabled true if enabled, false otherwise
///
/// \param completion Code to be executed upon completing the asynchronous request.
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)setVinylStartStopEnabled:(BOOL)enabled completion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Returns the on/off status of AutomixIQ.
/// <ul>
///   <li>
///     returns true if on, false otherwise.
///   </li>
/// </ul>
- (BOOL)on SWIFT_WARN_UNUSED_RESULT;
/// Sets the resolution of the waveform data for a track
/// \param waveformPointsPerTrack The number of points representing a waveform for a track, maximum of 1024, defaults to 256
///
- (void)setWaveformPointsPerTrack:(int32_t)waveformPointsPerTrack;
/// Gets the waveform data for a track.
/// <ul>
///   <li>
///     returns the waveform data
///   </li>
/// </ul>
/// \param identifier The identifier of a track
///
/// \param applyTransitions true if you want the transition to be applied to the waveform data, false if you want the original waveform data
///
- (AutomixIQWaveformModel * _Nullable)waveformDataForTrackWithIdentifier:(NSString * _Nonnull)identifier applyTransitions:(BOOL)applyTransitions SWIFT_WARN_UNUSED_RESULT;
/// Gets the waveform data for a track.
/// <ul>
///   <li>
///     returns the waveform data
///   </li>
/// </ul>
/// \param identifier The identifier of a track
///
/// \param applyEnterTransition true if you want the transition to the start of the track to be applied to the waveform data, false otherwise
///
/// \param applyExitTransition true if you want the transition to the end of the track to be applied to the waveform data, false otherwise
///
- (AutomixIQWaveformModel * _Nullable)waveformDataForTrackWithIdentifier:(NSString * _Nonnull)identifier applyEnterTransition:(BOOL)applyEnterTransition applyExitTransition:(BOOL)applyExitTransition SWIFT_WARN_UNUSED_RESULT;
/// Gets the placeholder waveform data for a track.
/// <ul>
///   <li>
///     returns the waveform data
///   </li>
/// </ul>
/// \param identifier The identifier of a track
///
- (AutomixIQWaveformModel * _Nullable)placeholderWaveformDataForTrackWithIdentifier:(NSString * _Nonnull)identifier SWIFT_WARN_UNUSED_RESULT;
/// Gets the current automix status
/// <ul>
///   <li>
///     returns the current automix status
///   </li>
/// </ul>
- (AutomixIQStatus * _Nullable)automixStatus SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC9AutomixIQ15AutomixIQConfig")
@interface AutomixIQConfig : NSObject
- (nonnull instancetype)initWithApiKey:(NSString * _Nonnull)apiKey country:(NSString * _Nonnull)country storeId:(NSString * _Nonnull)storeId applicationId:(NSString * _Nonnull)applicationId OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, copy) NSString * _Nonnull apiKey;
@property (nonatomic, copy) NSString * _Nonnull country;
@property (nonatomic, copy) NSString * _Nonnull storeId;
@property (nonatomic, copy) NSString * _Nonnull applicationId;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSData;

/// AutomixIQMusicCacheDelegate protocol defines the methods to be implemented with storing and providing cached track data
SWIFT_PROTOCOL("_TtP9AutomixIQ27AutomixIQMusicCacheDelegate_")
@protocol AutomixIQMusicCacheDelegate <NSObject>
/// Called by AutomixIQ when a track has been fully downloaded. This can be used to cache the track locally on the user’s device.
/// \param trackId The trackId of the asset in Tuned Global’s backend.
///
/// \param data The unencrypted track data.
///
- (void)trackDownloadCompletedWithTrackId:(NSString * _Nonnull)trackId data:(NSData * _Nonnull)data;
/// Called by AutomixIQ when a track download progress has changed.
/// \param trackId The id of the track that AutomixIQ is streaming.
///
/// \param progress The track download progress, between 0 (none) and 1 (complete).
///
- (void)trackDownloadProgressChangedWithTrackId:(NSString * _Nonnull)trackId progress:(float)progress;
/// Called by AutomixIQ before attempting to download a track to allow the client to provide any cached track data, return nil if not available.
/// \param trackId The id of the track that AutomixIQ is streaming.
///
///
/// returns:
/// the entire unencrypted track data, nil if not available.
- (NSData * _Nullable)getCachedTrackWithTrackId:(NSString * _Nonnull)trackId SWIFT_WARN_UNUSED_RESULT;
/// Called by AutomixIQ before attempting to download a tracks metadata to allow the client to provide any cached metadata, return nil if not available.
/// \param trackId The id of the track that AutomixIQ  is streaming.
///
///
/// returns:
/// the metadata of the track, nil if not available.
- (TunedTrackModel * _Nullable)getTrackMetadataWithTrackId:(NSString * _Nullable)trackId SWIFT_WARN_UNUSED_RESULT;
@end

/// AutomixIQPlaybackEventType is an enum of all the available playback events
/// \param trackPlayStart Start of track playback
///
/// \param trackPlayPlayed5Secs Track has played for 5 seconds
///
/// \param trackPlayHeartbeat30Secs Track has played for 30 seconds, this is called every 30 seconds of playback
///
/// \param trackPlayStartMixingIntoNext Track has started transitioning into the next track
///
/// \param trackPlaySkipped Track has been skipped to the next track (this is also called when seeking through the same track)
///
/// \param trackPlayFinished Track has finished playback (if transitioning this is called at the end of the transition for the first track)
///
/// \param mixPlaybackEnded Queue has reached the end and there are no more tracks to play
///
typedef SWIFT_ENUM(NSInteger, AutomixIQPlaybackEventType, open) {
  AutomixIQPlaybackEventTypeTrackPlayStart = 0,
  AutomixIQPlaybackEventTypeTrackPlayPlayed5Secs = 1,
  AutomixIQPlaybackEventTypeTrackPlayHeartbeat30Secs = 2,
  AutomixIQPlaybackEventTypeTrackPlayStartMixingIntoNext = 3,
  AutomixIQPlaybackEventTypeTrackPlaySkipped = 4,
  AutomixIQPlaybackEventTypeTrackPlayFinished = 5,
  AutomixIQPlaybackEventTypeMixPlaybackEnded = 6,
};

enum AutomixIQPlaylistOperationType : NSInteger;

/// AutomixIQPlaylistOperation models a move, add or remove operation of a track in a playlist.
SWIFT_CLASS("_TtC9AutomixIQ26AutomixIQPlaylistOperation")
@interface AutomixIQPlaylistOperation : NSObject
/// The type of operation, Add / Remove / Move
@property (nonatomic) enum AutomixIQPlaylistOperationType type;
/// The index int the playlist the track was removed from or was moved from, -1 otherwise.
@property (nonatomic) NSInteger fromIndex;
/// The index int the playlist the track was added to or was moved to, -1 otherwise.
@property (nonatomic) NSInteger toIndex;
/// The identifier of the track.
@property (nonatomic, copy) NSString * _Nullable trackIdentifier;
/// The unique identifier for this track in this playlist, i.e. if the same track happens to appear twice in a playlist this identifier will differ.
@property (nonatomic) NSInteger trackInstance;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM(NSInteger, AutomixIQPlaylistOperationType, open) {
  AutomixIQPlaylistOperationTypeAdded = 0,
  AutomixIQPlaylistOperationTypeRemoved = 1,
  AutomixIQPlaylistOperationTypeMoved = 2,
};

enum AutomixIQStatusVariable : NSInteger;
@class NSNumber;

/// AutomixIQStatus models the State of the AutomixIQ during playback.
SWIFT_CLASS("_TtC9AutomixIQ15AutomixIQStatus")
@interface AutomixIQStatus : NSObject <NSCopying>
/// Represents if sound is playing from Automix SDK, true if it is, false otherwise.
@property (nonatomic) BOOL playing;
/// Represents if more than one track is concurrently playing from Automix SDK (mixing), true if it is, false otherwise.
@property (nonatomic) BOOL mixing;
/// Represents the identifier of the currently playing track if not mixing, the front track of the two mixed together if mixing. This would be the track a UI needs to show as playing or active.
@property (nonatomic, copy) NSString * _Nullable playingTrackIdentifier;
/// Represents the position of the currently playing track in the playlist if not mixing, the front track of the two mixed together if mixing. This would be the track a UI needs to show as playing or active.
/// If seeking, it reports seek landing track index until jump is complete. This should be use on the UI.
@property (nonatomic) NSInteger playingTrackIndex;
/// Represents the current playback time of the playing track. If seeking, it reports seek landing time until jump is complete. This should be use on the UI.
@property (nonatomic) NSTimeInterval playingTrackCurrentTime;
/// Represents the total playback time of the playing track.
@property (nonatomic) NSTimeInterval playingTrackTotalTime;
/// Represents the percentage of downloaded track.
@property (nonatomic) float playingTrackStreamingProgress;
/// Represents wether the engine will replay the current playlist when it ends.
@property (nonatomic) BOOL replayOn;
/// Represents wether the engine is ready to skip to a previous track.
@property (nonatomic) BOOL canSkipToPrevious;
/// Represents wether the engine is ready to skip to the beginning of the current track.
@property (nonatomic) BOOL canBack;
/// Represents wether the engine is ready to skip to the next track. If playing the last track of the playlist and “repeat” is off, this will be false.
@property (nonatomic) BOOL canSkipToNext;
/// Represents wether the engine is ready to receive a play or pause command.
@property (nonatomic) BOOL canPlayPause;
/// Represents wether the engine is ready to receive a seek command.
@property (nonatomic) BOOL canSeek;
/// Represents wether the engine is ready to receive a reorder tracks command.
@property (nonatomic) BOOL canReorderTracks;
/// Represents wether the mix is readsy to play or currently loading.
@property (nonatomic) BOOL readyToPlay;
/// Represents wether the ‘next’ action would lead to a proper mix or a regular jumps. Depends on wether we had enough time to analyze the next track or not.
@property (nonatomic) BOOL canMixNow;
/// Represents the list of track identifiers in the order they will be played
@property (nonatomic, copy) NSArray<NSString *> * _Nonnull playlist;
/// Represents whether Automix SDK is muted or not. True if muted, false otherwise.
@property (nonatomic) BOOL muted;
/// Represents the Automix SDK play speed as a factor, from 0.5 to 2
@property (nonatomic) float playSpeed;
/// Represents the Automix SDK volume from 1 to 0. Note the device’s iOS Volume acts as a master over this one: if iOS’volume is 0, no sound will be put out regardless of this value.
@property (nonatomic) float normalisedVolume;
/// Represents the preferred Automix SDK transition duration, 0 if disabled.
@property (nonatomic) float preferredTransitionDurationSeconds;
/// Represents the track Automix SDK is currently looping, nil if none is looping
@property (nonatomic, copy) NSString * _Nullable requestedLoopTrackIdentifier;
/// Represents the track Automix SDK is currently flagged to be paused at the end, nil if none is
@property (nonatomic, copy) NSString * _Nullable requestedPauseTrackIdentifier;
/// Represents wether the engine does the vinyl sound effects when play/pause
@property (nonatomic) BOOL vinylStartStop;
/// Represents the duration of the upcoming transition, 0 if no transition available
@property (nonatomic) float nextTransitionDuration;
/// Represents the track time in seconds in which the next (or current) transition starts
@property (nonatomic) float transitionStartTimeSeconds;
/// Represents the tracks that failed loading for any reason
@property (nonatomic, copy) NSArray<NSString *> * _Nullable failedTrackLoadIdentifiers;
/// Represents if the SDK can be turned On or off. It is true if not other On / Off action is ongoing, flase otherwise. When this switch is true, On /Off actions return an error.
@property (nonatomic) BOOL canOnOff;
@property (nonatomic, copy) NSString * _Nullable playingTrackOriginalSessionId;
@property (nonatomic) BOOL explicitLyricsFiltering;
@property (nonatomic) int64_t mixId;
@property (nonatomic) NSInteger adIndex;
@property (nonatomic) BOOL playingAd;
/// Represents the total playback time of the playing Ad.
@property (nonatomic) float adTrackTotalTime;
/// Represents the current playback time of the playing Ad
@property (nonatomic) float adTrackCurrentTime;
@property (nonatomic, copy) NSDictionary<NSString *, NSArray<AutomixIQPlaylistOperation *> *> * _Nullable playlistDiff;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
+ (NSString * _Nonnull)automixIQStatusVariableName:(enum AutomixIQStatusVariable)variable SWIFT_WARN_UNUSED_RESULT;
- (id _Nonnull)variableValue:(enum AutomixIQStatusVariable)variable SWIFT_WARN_UNUSED_RESULT;
+ (NSArray<NSNumber *> * _Nonnull)allStatusVariables SWIFT_WARN_UNUSED_RESULT;
@end


/// AutomixIQStatusObserverDelegate protocol defines the methods to be implemented with observing the status of AutomixIQ to reflect it on a UI.
SWIFT_PROTOCOL("_TtP9AutomixIQ31AutomixIQStatusObserverDelegate_")
@protocol AutomixIQStatusObserverDelegate <NSObject>
/// Called when the status of AutomixIQ changes
/// \param variables a list of AutomixIQStatusVariable that changed since last time this method was called, or since AutomixIQ was initialised.
///
/// \param status the current status of AutomixIQ
///
- (void)statusChangedWithVariables:(NSArray<NSNumber *> * _Nonnull)variables status:(AutomixIQStatus * _Nonnull)status;
@optional
/// Called when a playback event of AutomixIQ happens
/// \param type the playback event type
///
/// \param identifier the track identifier this event refers to
///
/// \param originalSessionId the initial session id for the track this event refers to. AutomixIQ may use more session ids as needed if the session expires and it needs more data.
///
/// \param status the current status of AutomixIQ
///
- (void)playbackEventWithType:(enum AutomixIQPlaybackEventType)type identifier:(NSString * _Nullable)identifier originalSessionId:(NSString * _Nullable)originalSessionId status:(AutomixIQStatus * _Nullable)status;
/// Called when waveform data for a track is available
/// \param identifier the identifier of the track
///
- (void)waveformDataAvailableWithIdentifier:(NSString * _Nonnull)identifier;
@end

/// AutomixIQ status variable type
typedef SWIFT_ENUM(NSInteger, AutomixIQStatusVariable, open) {
  AutomixIQStatusVariablePlaying = 0,
  AutomixIQStatusVariableMixing = 1,
  AutomixIQStatusVariablePlayingTrackIdentifier = 2,
  AutomixIQStatusVariablePlayingTrackIndex = 3,
  AutomixIQStatusVariablePlayingTrackCurrentTime = 4,
  AutomixIQStatusVariablePlayingTrackTotalTime = 5,
  AutomixIQStatusVariablePlayingTrackStreamingProgress = 6,
  AutomixIQStatusVariableReplayOn = 7,
  AutomixIQStatusVariableCanSkipToPrevious = 8,
  AutomixIQStatusVariableCanBack = 9,
  AutomixIQStatusVariableCanSkipToNext = 10,
  AutomixIQStatusVariableCanPlayPause = 11,
  AutomixIQStatusVariableCanSeek = 12,
  AutomixIQStatusVariableCanReorderTracks = 13,
  AutomixIQStatusVariableReadyToPlay = 14,
  AutomixIQStatusVariableCanMixNow = 15,
  AutomixIQStatusVariablePlaylist = 16,
  AutomixIQStatusVariableMuted = 17,
  AutomixIQStatusVariablePlaySpeed = 18,
  AutomixIQStatusVariableNormalisedVolume = 19,
  AutomixIQStatusVariablePreferredTransitionDurationSeconds = 20,
  AutomixIQStatusVariableRequestedLoopTrackIdentifier = 21,
  AutomixIQStatusVariableRequestedPauseTrackIdentifier = 22,
  AutomixIQStatusVariableVinylStartStop = 23,
  AutomixIQStatusVariableNextTransitionDuration = 24,
  AutomixIQStatusVariableTransitionStartTimeSeconds = 25,
  AutomixIQStatusVariableFailedTrackLoadIdentifiers = 26,
  AutomixIQStatusVariableCanOnOff = 27,
  AutomixIQStatusVariablePlayingTrackOriginalSessionId = 28,
  AutomixIQStatusVariableExplicitLyricsFiltering = 29,
  AutomixIQStatusVariableMixId = 30,
  AutomixIQStatusVariablePlaylistDiff = 31,
  AutomixIQStatusVariableAdIndex = 32,
  AutomixIQStatusVariablePlayingAd = 33,
  AutomixIQStatusVariableAdTrackTotalTime = 34,
  AutomixIQStatusVariableAdTrackCurrentTime = 35,
};

enum TunedLogLevel : NSInteger;

/// AutomixIQStreamingDelegate protocol defines the methods to be implemented with providing AutomixIQ the information it requires to play content.
SWIFT_PROTOCOL("_TtP9AutomixIQ26AutomixIQStreamingDelegate_")
@protocol AutomixIQStreamingDelegate <NSObject>
@optional
/// Called by AutomixIQ when it wishes to output a log message
/// \param logLevel The log level
///
/// \param message The message it wishes to log.
///
- (void)logAutomixIQMessageWithLogLevel:(enum TunedLogLevel)logLevel message:(NSString * _Nonnull)message;
@required
/// Called by AutomixIQ to learn if it is allowed to stream content that is protected by some form of authentication.
/// An example is, an implementation via an API behind OAuth would return true if access and refresh tokens are available, false otherwise
///
/// returns:
/// true if it is allowed or there are no authentication requirements, false otherwise
- (BOOL)isLoggedIn SWIFT_WARN_UNUSED_RESULT;
/// Called by AutomixIQ regularly while something is being played, this can be used if you have restrictions on the number of devices that can play simultaneously
/// \param completion Code to be executed upon completing the asynchronous request
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// <li>
/// canContinuePlaying: true if the device can continue playing, false otherwise..
/// </li>
/// </ul>
///
///
- (void)asyncCheckDeviceStatusWithCompletion:(void (^ _Nonnull)(NSError * _Nullable, BOOL))completion;
/// Called by Automix to learn the identity of the device requesting to stream audio, for those services that require it.
/// An example would be, a service that only allows one device to stream at any one time, would need to know the identity of the device to provide the stream.
///
/// returns:
/// the unique identifier of the device that will be streaming content, nil if unknown or unnecessary
- (NSString * _Nullable)getDeviceIdentifier SWIFT_WARN_UNUSED_RESULT;
/// Called by AutomixIQ to obtain the URL to stream audio from, a sessionId if the URL is to be salted with one, and the URL to report playback events if required.
/// \param streamingDeviceId The id of the device attempting to stream content within the streaming APIs.
///
/// \param sessionId The current session Id if available. If one is provided and no longer valid a renewed one will be returned.
///
/// \param trackId The id of the track that AutomixIQ is attempting to stream.
///
/// \param completion Code to be executed upon completing the asynchronous request
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// <li>
/// url: the URL that points to the asset to be played, nil in case of an error.
/// </li>
/// <li>
/// newSessionId: the session Id of the stream, nil if not required or not available.
/// </li>
/// <li>
/// reportingURLS: the set of reporting URLs if available, nil otherwise.
/// </li>
/// </ul>
///
///
- (void)asyncGetStreamWithStreamingDeviceId:(NSString * _Nonnull)streamingDeviceId sessionId:(NSString * _Nonnull)sessionId trackId:(NSString * _Nonnull)trackId completion:(void (^ _Nonnull)(NSError * _Nullable, NSString * _Nullable, NSString * _Nullable))completion;
/// Called by AutomixIQ when it requires the metadata of a track in order to load it.
/// \param trackId The id of the track that AutomixIQ is attempting to stream.
///
/// \param completion Code to be executed upon completing the asynchronous request
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// <li>
/// track: the metadata of the track, nil if an error ocurred.
/// </li>
/// </ul>
///
///
- (void)asyncGetTrackMetadataWithTrackId:(NSString * _Nonnull)trackId completion:(void (^ _Nonnull)(NSError * _Nullable, TunedTrackModel * _Nullable))completion;
/// Called by AutomixIQ when playback of a track has fulfilled the requirements to report a playback event.
/// \param trackId The id of the track that AutomixIQ is streaming.
///
/// \param seconds The number of seconds the track has been playing up until this time.
///
/// \param guid the identifier of this play
///
/// \param logPlayType A descriptor of the event, one of the following: “Start”, “End”, “Progress”, “Skip”, “Unknown”.
///
/// \param source A descriptor of the type of source of the track being reported, like “Album”, “Playlist”, etc.
///
/// \param sourceId An identifier of the source of the track being reported.
///
/// \param completion Code to be executed upon completing the asynchronous request
///
/// \a completion parameters:
/// <ul>
/// <li>
/// success: true if the report was filed successfully, false otherwise.
/// </li>
/// </ul>
///
///
- (void)asyncLogPlayEventWithTrackId:(NSString * _Nonnull)trackId seconds:(NSInteger)seconds guid:(NSString * _Nonnull)guid logPlayType:(NSString * _Nonnull)logPlayType source:(NSString * _Nullable)source sourceId:(NSInteger)sourceId completion:(void (^ _Nonnull)(BOOL))completion;
/// Called by AutomixIQ when a track has been fully downloaded. This can be used to cache the track locally on the user’s device.
/// \param trackId The id of the track that the AutomixIQ SDK is streaming.
///
/// \param data The track data as an array of bytes.
///
- (void)trackDownloadCompletedWithTrackId:(NSString * _Nonnull)trackId data:(NSData * _Nonnull)data;
/// Called by AutomixIQ when a track download progress has changed.
/// \param trackId The id of the track that AutomixIQ is streaming.
///
/// \param progress The track download progress, between 0 (none) and 1 (complete).
///
- (void)trackDownloadProgressChangedWithTrackId:(NSString * _Nonnull)trackId progress:(float)progress;
/// Called by AutomixIQ before attempting to download a track to allow the client to provide any cached track data, return nil if not available.
/// \param trackId The id of the track that AutomixIQ is streaming.
///
///
/// returns:
/// the entire unencrypted track data, nil if not available.
- (NSData * _Nullable)syncGetCachedTrackWithTrackId:(NSString * _Nonnull)trackId SWIFT_WARN_UNUSED_RESULT;
/// Called by AutomixIQ before attempting to download a tracks metadata to allow the client to provide any cached metadata, return nil if not available.
/// \param trackId The id of the track that AutomixIQ  is streaming.
///
///
/// returns:
/// the metadata of the track, nil if not available.
- (TunedTrackModel * _Nullable)syncGetTrackMetadataWithTrackId:(NSString * _Nullable)trackId SWIFT_WARN_UNUSED_RESULT;
/// AutomixIQ calls this function to provide a chance to cache metadata to shortcut future requests.
- (void)cacheMetadata:(NSArray<TunedTrackModel *> * _Nonnull)metadata;
/// AutomixIQ calls this function to provide a chance to cache Ads and inform it if it can actually play them.
/// \param metadata The metadata for the ads.
///
/// \param completion Code to be executed upon completing the asynchronous request
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error the error if there was one: 
/// </li>
/// <li>
/// canPlay true if the ads are playable, false otherwise.: 
/// </li>
/// </ul>
///
///
- (void)canPlayAdsWithMetadata:(NSArray<TunedAdModel *> * _Nonnull)metadata completion:(void (^ _Nonnull)(NSError * _Nullable, BOOL))completion;
@end


/// AutomixIQWaveformModel models the waveform of a track.
SWIFT_CLASS("_TtC9AutomixIQ22AutomixIQWaveformModel")
@interface AutomixIQWaveformModel : NSObject
/// The normalised X axis, from 0 (meaning start of the track) to 1 (meaning end of the track)
@property (nonatomic, copy) NSArray<NSNumber *> * _Nullable xAxis;
/// The energy of the track
@property (nonatomic, copy) NSArray<NSNumber *> * _Nullable yAxis;
/// The index the left transition starts
@property (nonatomic) NSInteger leftTransitionStartIndex;
/// The index the left transition ends
@property (nonatomic) NSInteger leftTransitionEndIndex;
/// The index the right transition starts
@property (nonatomic) NSInteger rightTransitionStartIndex;
/// The index the right transition ends
@property (nonatomic) NSInteger rightTransitionEndIndex;
/// The number of indices representing a second (x-axis scale)
@property (nonatomic) float indicesPerSecond;
/// The time in the track the left transition starts at, in seconds
@property (nonatomic) float leftTransitionStartTime;
/// The time in the track the left transition ends at, in seconds
@property (nonatomic) float leftTransitionEndTime;
/// The duration of the left transition in track time, in seconds
@property (nonatomic) float leftTransitionDuration;
/// The time in the track the right transition starts at, in seconds
@property (nonatomic) float rightTransitionStartTime;
/// The time in the track the right transition ends at, in seconds
@property (nonatomic) float rightTransitionEndTime;
/// The duration of the right transition, in seconds
@property (nonatomic) float rightTransitionDuration;
/// The duration of the track, in seconds
@property (nonatomic) float trackDurationSeconds;
/// true if this waveform is placeholder data, false otherwise
@property (nonatomic) BOOL placeholder;
/// The time in the current track where the next track’s starting duration would be. This is not where the next track would begin playback as the first few seconds may be muted to create a better transition.
/// This is helpful to align waveforms when rendering transitions.
@property (nonatomic) float nextTrack0SecondsAnchorTime;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// \param notMainThread Thrown when you attempt to use the SDK from any thread not main
///
/// \param sdkNotInitialised Thrown when you attempt to use the SDK prior to initialising it
///
/// \param sdkNotOn Thrown when you attempt to use playback controls when AutomixIQ is not on
///
/// \param sdkAlreadyOn Thrown when you attempt to turn on AutomixIQ but it is already on
///
/// \param loadTracksEmptyPlaylist Thrown when you attempt to load an empty playlist
///
/// \param loadTracksOutOfBounds 
///
/// \param addTrackPlaylistDoesNotExist 
///
/// \param addTrackOutOfBounds Thrown when you attempt to insert a track at a position outside the bounds of the loaded playlist
///
/// \param addTrackNoMetadata Thrown when the metadata for a track you are trying to load is not available and could not be downloaded
///
/// \param addTrackInternalError Thrown when AutomixIQ fails internally (not user error)
///
/// \param removeTrackOutOfBounds Thrown when you attempt to remove a track at a position outside the bounds of the loaded playlist
///
/// \param playAlreadyPlaying Thrown when you attempt to play but AutomixIQ is already playing
///
/// \param pauseAlreadyPaused Thrown when you attempt to pause but AutomixIQ is already paused
///
/// \param previousNoTrackAvailable Thrown when you attempt to go to the previous track but AutomixIQ is already on the first in the playlist and “Repeat” is off
///
/// \param nextNoTrackAvailable Thrown when you attempt to go to the next track but AutomixIQ is already on the last in the playlist and “Repeat” is off
///
/// \param backNoTrackAvailable Thrown when you attempt to go to the start of a track but the playlist is empty
///
/// \param seekNoTrackAvailable Thrown when you attempt to seek to a track but the playlist is empty or the index is out of bounds of the playlist
///
/// \param seekNoCurrentTrack Thrown when you attempt to seek within a track but the playlist is empty or the track is not yet loaded
///
/// \param reorderMissingTrack Thrown when you attempt to move a track that is not on the loaded playlist
///
/// \param playToEndMissingTrack Thrown when you attempt to select a track to be played until the end but that track is not on the loaded playlist
///
/// \param moveTrackOutOfBounds Thrown when you attempt to move a track at a position outside the bounds of the loaded playlist
///
/// \param startLoopingNoLoopingTrack Thrown when you attempt to stop looping a track but that track is not on the loaded playlist
///
/// \param stopLoopingNoLoopingTrack Thrown when you attempt to loop a track but that track is not on the loaded playlist
///
/// \param unimplemented Thrown when you attempt to use an unimplemented method of the SDK
///
/// \param cancelled Thrown when an action you previously issued to AutomixIQ is cancelled due to another user initialed action that overrides it
///
/// \param onAlreadyTurningOn Thrown when you attempt to turn AutomixIQ on while it is already turning on
///
/// \param onWhileTurningOff Thrown when you attempt to turn AutomixIQ on while it is already turning off
///
/// \param offAlreadyTurningOff Thrown when you attempt to turn AutomixIQ off while it is already turning off
///
/// \param offWhileTurningOn Thrown when you attempt to turn AutomixIQ off while it is already turning on
///
/// \param cannotCreateChannelLayout Thrown when AutomixIQ fails to set up the channel layout
///
/// \param cannotCreateInputBuffer Thrown when AutomixIQ fails to set up the input buffer
///
/// \param cannotSetupAVAudioSession Thrown when AutomixIQ fails to set up the AVAudioSession
///
/// \param cannotStartAudioEngine Thrown when AutomixIQ fails to start the audio engine
///
/// \param cannotRestoreAudioSession Thrown when AutomixIQ fails to restore the audio session to the state it found it when you turned it on
///
/// \param failedToStop Thrown when AutomixIQ is unable to be stopped
///
/// \param cannotLoadExplicitLyricsTrack Thrown when you attempt to load an explicit track but the setting to filter out explicit tracks is on
///
/// \param cannotDownloadAd Thrown when you fail to download the ad from the url provided
///
/// \param cannotInterruptAd Thrown when you attempt to do something you cannot do while playing an ad
///
typedef SWIFT_ENUM(NSInteger, ErrorCode, open) {
  ErrorCodeSdkAlreadyInitialised = 1001,
  ErrorCodeSdkInitialisationUnauthorised = 1002,
  ErrorCodeNoInternetAvailable = 1003,
  ErrorCodeNoInternetAvailableTooLongOffline = 1004,
  ErrorCodeOfflineNoTunedUserIdAvailable = 1005,
  ErrorCodeNotMainThread = 1006,
  ErrorCodeSdkNotInitialised = 1007,
  ErrorCodeSdkNotInitialisedVersionNoLongerSupported = 1008,
  ErrorCodeSdkNotOn = 1009,
  ErrorCodeSdkAlreadyOn = 1010,
  ErrorCodeLoadTracksEmptyPlaylist = 1011,
  ErrorCodeLoadTracksOutOfBounds = 1012,
  ErrorCodeAddTrackPlaylistDoesNotExist = 1013,
  ErrorCodeAddTrackOutOfBounds = 1014,
  ErrorCodeAddTrackNoMetadata = 1015,
  ErrorCodeAddTrackInternalError = 1016,
  ErrorCodeRemoveTrackOutOfBounds = 1017,
  ErrorCodePlayAlreadyPlaying = 1018,
  ErrorCodePauseAlreadyPaused = 1019,
  ErrorCodeNextNoTrackAvailable = 1020,
  ErrorCodePreviousNoTrackAvailable = 1021,
  ErrorCodeBackNoTrackAvailable = 1022,
  ErrorCodeSeekNoTrackAvailable = 1023,
  ErrorCodeSeekNoCurrentTrack = 1024,
  ErrorCodeReorderMissingTrack = 1025,
  ErrorCodePlayToEndMissingTrack = 1026,
  ErrorCodePlayToEndMixEnd = 1027,
  ErrorCodeMoveTrackOutOfBounds = 1028,
  ErrorCodeStartLoopingNoLoopingTrack = 1029,
  ErrorCodeStopLoopingNoLoopingTrack = 1030,
  ErrorCodeUnable_to_load_mix = 1031,
  ErrorCodeUnimplemented = 1032,
  ErrorCodeCancelled = 1033,
  ErrorCodeOnAlreadyTurningOn = 1034,
  ErrorCodeOnWhileTurningOff = 1035,
  ErrorCodeOffAlreadyTurningOff = 1036,
  ErrorCodeOffWhileTurningOn = 1037,
  ErrorCodeCannotCreateChannelLayout = 1038,
  ErrorCodeCannotCreateInputBuffer = 1039,
  ErrorCodeCannotSetupAVAudioSession = 1040,
  ErrorCodeCannotStartAudioEngine = 1041,
  ErrorCodeCannotRestoreAudioSession = 1042,
  ErrorCodeFailedToStop = 1043,
  ErrorCodeCannotLoadExplicitLyricsTrack = 1044,
  ErrorCodeCannotDownloadAd = 1045,
  ErrorCodeCannotInterruptAd = 1046,
};

@class TunedArtistModel;

/// TunedAdModel models a Ad.
SWIFT_CLASS("_TtC9AutomixIQ12TunedAdModel")
@interface TunedAdModel : NSObject
/// The identifier of a track as an integer
@property (nonatomic, copy) NSString * _Nonnull adId;
/// The url where this ad is downloaded from
@property (nonatomic, copy) NSString * _Nonnull url;
/// The title of this Ad
@property (nonatomic, copy) NSString * _Nullable name;
/// The artists of this ad
@property (nonatomic, copy) NSArray<TunedArtistModel *> * _Nullable artists;
/// The artwork of this ad
@property (nonatomic, copy) NSString * _Nullable image;
/// Objective-C accessible member for the duration
@property (nonatomic, readonly) NSInteger adDuration;
/// Initialises an Ad Model
/// \param adId The identifier of a track as an integer
///
/// \param url The url where this ad is downloaded from
///
/// \param duration The duration of this ad
///
/// \param name The title of this Ad
///
/// \param artists The artists of this ad
///
/// \param image The artwork of this ad
///
- (nonnull instancetype)initWithAdId:(NSString * _Nonnull)adId url:(NSString * _Nonnull)url duration:(NSInteger)duration name:(NSString * _Nullable)name artists:(NSArray<TunedArtistModel *> * _Nullable)artists image:(NSString * _Nullable)image OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// TunedArtistModel models an artist.
SWIFT_CLASS("_TtC9AutomixIQ16TunedArtistModel")
@interface TunedArtistModel : NSObject
/// The artist name.
@property (nonatomic, copy) NSString * _Nullable Name;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// TunedAuthenticationResponse models the response of a Tuned OAuth request
SWIFT_CLASS("_TtC9AutomixIQ27TunedAuthenticationResponse")
@interface TunedAuthenticationResponse : NSObject
/// The access token
@property (nonatomic, copy) NSString * _Nullable access_token;
/// The token type
@property (nonatomic, copy) NSString * _Nullable token_type;
/// The refresh token
@property (nonatomic, copy) NSString * _Nullable refresh_token;
/// The Id of the authenticated user in Tuned Global’s backend
@property (nonatomic, copy) NSString * _Nullable tuned_user_id;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// TunedLogLevel is an enum of all the AutomixIQ available log levels
/// \param logLevelTrace AutomixIQ logs with no filter
///
/// \param logLevelDebug AutomixIQ logs everything except low level details
///
/// \param logLevelInfo AutomixIQ logs everything except low level details and debug statements
///
/// \param logLevelWarning AutomixIQ only logs errors and warnings
///
/// \param logLevelError AutomixIQ only logs errors
///
/// \param logLevelFatal AutomixIQ only logs fatal errors
///
typedef SWIFT_ENUM(NSInteger, TunedLogLevel, open) {
  TunedLogLevelLogLevelTrace = 0,
  TunedLogLevelLogLevelDebug = 1,
  TunedLogLevelLogLevelInfo = 2,
  TunedLogLevelLogLevelWarning = 3,
  TunedLogLevelLogLevelError = 4,
  TunedLogLevelLogLevelFatal = 5,
};


/// TunedPluginMetadataModel models metadata of a track traditionally obtained by running plugins on it. Key and BPM are recommented for best mixing.
/// The Type entry for bpm and key are “key” and “bpm” (case sensitive) respectively, the values need to be formatted as strings, and the key needs to be in OpenKey format.
SWIFT_CLASS("_TtC9AutomixIQ24TunedPluginMetadataModel")
@interface TunedPluginMetadataModel : NSObject
/// The Type of metadata described by this object, examples: “key”, “bpm”
@property (nonatomic, copy) NSString * _Nullable Type;
/// The value of the metadata
@property (nonatomic, copy) NSString * _Nullable Meta;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// TunedRestDelegate protocol defines the methods to be implemented that will provide AutomixIQ the credentials and identifiers to Tuned Global’s backend
SWIFT_PROTOCOL("_TtP9AutomixIQ17TunedRestDelegate_")
@protocol TunedRestDelegate <NSObject>
/// Called by AutomixIQ when initialised against a Tuned Global backend or when its access token has expired.
/// \param deviceIdentifierForVendor The unique identifier of the device.
///
/// \param countryCode The ISO2 code of the country the device is located.
///
/// \param tunedUserId The user’s id within the Tuned Global backend.
///
/// \param oldAccessToken The expired access token.
///
/// \param refreshToken The refresh token.
///
/// \param tokenType The token type.
///
/// \param completion Code to be executed upon completing the asynchronous request
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// <li>
/// credentials: The refreshed credentials
/// </li>
/// <li>
/// tunedUserId: The user’s id within the Tuned Global backend.
/// </li>
/// </ul>
///
///
- (void)tunedRestTokenExpiredWithDeviceIdentifierForVendor:(NSString * _Nonnull)deviceIdentifierForVendor countryCode:(NSString * _Nonnull)countryCode tunedUserId:(NSString * _Nullable)tunedUserId oldAccessToken:(NSString * _Nullable)oldAccessToken refreshToken:(NSString * _Nullable)refreshToken tokenType:(NSString * _Nullable)tokenType completion:(void (^ _Nonnull)(NSError * _Nullable, TunedAuthenticationResponse * _Nullable, NSString * _Nullable))completion;
@optional
/// Called by AutomixIQ while initialising to give you an opportunity to provide the authenticated device ID or perform device authentication as required.
/// If not implemented, AutomixIQ will proceed to register a device for the logged in user with deviceType: “iPhone”, displayName: “AutomixIQ” and deviceOS: “iOS”.
/// \param deviceIdentifierForVendor The unique identifier of the device
///
/// \param completion Code to be executed upon completing the asynchronous request
///
/// \a completion parameters:
/// <ul>
/// <li>
/// error: An error describing a problem that occurred, nil otherwise.
/// </li>
/// <li>
/// tunedDeviceId: The device id within the Tuned Global backend as a String, nil if there was an error.
/// </li>
/// </ul>
///
///
- (void)asyncGetAuthenticatedDeviceWithDeviceIdentifierForVendor:(NSString * _Nonnull)deviceIdentifierForVendor completion:(void (^ _Nonnull)(NSError * _Nullable, NSString * _Nullable))completion;
@required
/// Called by AutomixIQ to request the unique identifier for the users device as a string.
/// On iOS this is generally the Identifier for Vendor.
/// It can be any string as long as it is unique
/// AutomixIQ will use this string as the UniqueId if it needs to register the device for playback
///
/// returns:
/// The unique device identifier as string
- (NSString * _Nonnull)uniqueDeviceIdentifier SWIFT_WARN_UNUSED_RESULT;
/// Called by AutomixIQ to learn if it should log playback events to Tuned’s backend on your behalf or if you will implement logging yourself.
///
/// returns:
/// true if AutomixIQ is to log playback events automatically, false if you take the responsibility of logging playback events yourself.
- (BOOL)automaticallyLogPlayback SWIFT_WARN_UNUSED_RESULT;
@optional
/// Called by AutomixIQ when it wishes to output a log message
/// \param logLevel The log level.
///
/// \param message The message it wishes to log.
///
- (void)logAutomixIQMessageWithLogLevel:(enum TunedLogLevel)logLevel message:(NSString * _Nonnull)message;
@end


/// Tuned Store settings
SWIFT_CLASS("_TtC9AutomixIQ18TunedStoreSettings")
@interface TunedStoreSettings : NSObject
@property (nonatomic, copy) NSString * _Nullable minAutoMixSdkVersion;
@property (nonatomic, copy) NSString * _Nullable minRadioSdkVersion;
@property (nonatomic, copy) NSString * _Nullable mqttBrokerAddress;
@property (nonatomic, readonly) BOOL automixIQEnabled;
@property (nonatomic, readonly) BOOL socialRadioEnabled;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// TunedTrackModel models a track. This metadata is required.
SWIFT_CLASS("_TtC9AutomixIQ15TunedTrackModel")
@interface TunedTrackModel : NSObject
/// The artists of a track - the first one is the one to be presented by a UI
@property (nonatomic, copy) NSArray<TunedArtistModel *> * _Nullable Artists;
/// The title of a track
@property (nonatomic, copy) NSString * _Nullable Name;
/// The name of the album this track belongs to
@property (nonatomic, copy) NSString * _Nullable ReleaseName;
/// Objective-C accessible member for the track identifier as String
@property (nonatomic, copy) NSString * _Nonnull trackIdentifier;
/// Objective-C accessible member for the track number
@property (nonatomic) NSInteger trackNumber;
/// Objective-C accessible member for the track duration
@property (nonatomic) NSInteger duration;
/// Objective-C accessible member for the key, nil if unavailable
@property (nonatomic, readonly, copy) NSString * _Nullable key;
/// Objective-C accessible member for IsExplicit
@property (nonatomic) BOOL isExplicit;
/// Objective-C accessible member for IsAd
@property (nonatomic) BOOL isAd;
/// Objective-C accessible member for the bpm, 09 if unavailable
@property (nonatomic, readonly) double bpm;
/// The url of the artwork image for this track as a String
@property (nonatomic, copy) NSString * _Nullable Image;
/// Initialises a Track Model
/// \param trackId The identifier of the track
///
/// \param artistName The name of the main artist of the track
///
/// \param name The title of the track
///
/// \param duration The track duration in seconds
///
/// \param isExplicit true if the track contains explicit lyrics, false otherwise
///
/// \param isAd true if the track is an Ad, false otherwise
///
/// \param trackNumber The index of the track in the album it was released in
///
/// \param releaseName The nemae of the release this track’s in
///
/// \param key The key of this track as a String in Camelot format, i.e. 8m, nil if unavailable
///
/// \param tempo The bpm of this track as a float
///
/// \param image The url of the artwork image for this track as a String
///
- (nonnull instancetype)initWithTrackId:(NSString * _Nonnull)trackId artistName:(NSString * _Nonnull)artistName name:(NSString * _Nonnull)name duration:(NSInteger)duration isExplicit:(BOOL)isExplicit isAd:(BOOL)isAd trackNumber:(NSInteger)trackNumber releaseName:(NSString * _Nonnull)releaseName key:(NSString * _Nullable)key tempo:(float)tempo image:(NSString * _Nullable)image OBJC_DESIGNATED_INITIALIZER;
+ (TunedTrackModel * _Nonnull)fromTunedAd:(TunedAdModel * _Nonnull)tunedAd SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, _HMACAlgorithm, open) {
  _HMACAlgorithmMD5 = 0,
  _HMACAlgorithmSHA1 = 1,
  _HMACAlgorithmSHA224 = 2,
  _HMACAlgorithmSHA256 = 3,
  _HMACAlgorithmSHA384 = 4,
  _HMACAlgorithmSHA512 = 5,
};

#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
